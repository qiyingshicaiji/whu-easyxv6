# 实验4&5&6：中断处理、进程管理与系统调用（综合实验报告）

说明：本文件将实验4/5/6 汇总在同一份文档中，
---

# 实验4：中断处理与时钟管理

## 一、实验概述

### 1.1 实验目标
1. 理解 RISC-V trap/interrupt 机制与特权级切换（M/S/U）
2. 搭建完整的内核 trap 处理框架（内核态与用户态 trap）
3. 实现时钟中断处理：ticks 维护、唤醒睡眠进程、驱动抢占式调度
4. 实现外设中断处理：PLIC 初始化、claim/complete 与设备中断分发

### 1.2 完成情况（结合本工程实现）
- ✅ M 模式时钟中断入口：`kernel/dev/timer.c` 的 `timer_init()` 配置 `mtvec=timer_vector`
- ✅ S 模式内核 trap 入口：`kernel/trap/trap.S` 提供 `kernel_vector`
- ✅ 内核态 trap 分发：`kernel/trap/trap_kernel.c` 的 `trap_kernel_handler()`
- ✅ 时钟中断处理：`kernel/trap/trap_kernel.c` 的 `timer_interrupt_handler()`
- ✅ PLIC 外部中断：`kernel/dev/plic.c` + `kernel/trap/trap_kernel.c` 的 `external_interrupt_handler()`
- ✅ 用户态 trap 处理：`kernel/trap/trap_user.c` 的 `trap_user_handler()`

### 1.3 开发环境
- OS：Windows（本机）
- 目标架构：RISC-V 64
- 模拟器：QEMU virt
- 工具链：riscv64-unknown-elf-gcc（或等价 RISC-V 交叉编译工具链）

---

## 二、技术设计

### 2.1 RISC-V 中断/异常基础（本实验需要掌握的点）

#### 2.1.1 三种特权级与 trap 入口
RISC-V 将执行环境划分为：
- **M-mode（Machine）**：最高特权级，硬件资源控制最完整
- **S-mode（Supervisor）**：操作系统内核运行模式
- **U-mode（User）**：用户程序运行模式

当发生中断/异常时，CPU 会进入 trap：
- `scause`：原因（中断/异常 + 具体编号）
- `sepc`：trap 发生时的 PC
- `sstatus`：状态（包含前一特权级等）
- `stval`：附加信息（如异常地址）

#### 2.1.2 为什么需要“时钟中断驱动调度”
只有硬件时钟能提供稳定的节拍（tick），让 OS 能够：
- 周期性抢占正在运行的进程（避免某进程无限占用 CPU）
- 驱动 `sleep` 的超时/计时逻辑
- 作为内核“时间基准”提供 `uptime` 类功能

### 2.2 时钟中断完整链路（本工程实际实现）

本实验的时钟中断采用“**M 模式时钟中断 → 触发 S 模式软件中断 → S 模式处理并调度**”的典型方案：

```
CLINT 产生 M-mode timer interrupt
	↓
M-mode: timer_vector（汇编入口）
	- 更新 CLINT_MTIMECMP，设置下一次中断
	- 设置 SIP.SSIP（触发 S-mode 软件中断）
	↓
S-mode: kernel_vector（kernel/trap/trap.S）
	- 保存寄存器现场
	- 调用 trap_kernel_handler()
	↓
trap_kernel_handler() 根据 scause 分发
	↓
timer_interrupt_handler()
	- timer_update(): ticks++
	- proc_wakeup(&ticks)
	- 清除 SSIP
	↓
如当前有 RUNNING 进程，则 proc_yield() 触发调度
```

对应文件：
- `kernel/dev/timer.c`：`timer_init()`、`timer_vector`、`timer_update()`、`timer_get()`
- `kernel/trap/trap.S`：`kernel_vector`
- `kernel/trap/trap_kernel.c`：`trap_kernel_handler()`、`timer_interrupt_handler()`

### 2.3 外部中断与 PLIC 设计
外部设备（如 UART、virtio）通过 PLIC 上报中断：

```
设备产生中断
	↓
PLIC 挂起中断号
	↓
S-mode trap → trap_kernel_handler()
	↓
external_interrupt_handler()
	- plic_claim() 获取中断源
	- 分发给对应设备 handler
	- plic_complete() 完成中断
```

对应文件：
- `kernel/dev/plic.c`：`plic_init()`、`plic_claim()`、`plic_complete()`
- `kernel/trap/trap_kernel.c`：`external_interrupt_handler()`
- `kernel/dev/uart.c` 等：设备侧中断处理

---

## 三、实现细节

### 3.1 trap 汇编入口：kernel_vector
`kernel/trap/trap.S` 的 `kernel_vector` 负责：
1. 保存通用寄存器到当前内核栈
2. 调用 C 语言 handler：`trap_kernel_handler()`
3. 从栈恢复寄存器
4. `sret` 返回

这一步的设计理由：
- C 代码不适合直接处理“保存所有寄存器”这类固定序列
- 汇编入口保证现场完整可控，C 层只关心“分发与处理”

### 3.2 内核态 trap 分发：trap_kernel_handler
位于 `kernel/trap/trap_kernel.c`：
- 根据 `scause` 判断是软件/时钟相关中断还是外部中断
- 时钟相关：调用 `timer_interrupt_handler()`
- 外部中断：调用 `external_interrupt_handler()`
- 在需要抢占时调用 `proc_yield()`

### 3.3 时钟中断处理：timer_interrupt_handler
位于 `kernel/trap/trap_kernel.c`，关键动作：
- `timer_update()` 更新 ticks
- `proc_wakeup(&timer_get()->ticks)` 唤醒在 ticks 上 sleep 的进程
- 清除 SSIP：`w_sip(r_sip() & ~2)`

### 3.4 用户态 trap：trap_user_handler（与实验6也有关）
位于 `kernel/trap/trap_user.c`，主要分三类：
1. 用户态系统调用（`scause==8`）：进入 `syscall()`
2. 用户态被中断打断：时钟中断可能触发 `proc_yield()`
3. 用户态异常：打印信息并 `panic`（或标记 killed）

用户态 trap 处理完后会进入 `trap_user_return()`，通过 trampoline 切回用户页表并 `sret` 回用户态。

---

## 四、测试与结果

### 4.1 时钟中断可用性
验证点：
- ticks 能够持续递增（可通过打印/调试观察）
- `sleep(n)` 能在 ticks 基础上正确返回

### 4.2 抢占式调度是否生效
验证点：
- 多个用户进程并发运行时，单个进程无法永久占用 CPU
- 时钟中断触发 `proc_yield()`，系统能切换到其他 RUNNABLE 进程

### 4.3 外设中断链路是否可用
验证点：
- UART 输入/输出正常（通常依赖 PLIC 外部中断）
- virtio 磁盘中断正常（若实验中涉及文件系统/块设备读写）

---

## 五、实验总结
本实验完成了从 M 模式时钟中断到 S 模式内核处理的完整链路，并将时钟中断与进程调度结合，为后续实验5（进程调度）与实验6（系统调用）提供了可靠的“异步事件入口”。

---

# 实验5：进程管理与调度

## 一、实验概述

### 1.1 实验目标
1. 建立进程抽象：PCB（`proc_t`）、进程状态机与父子关系
2. 实现进程生命周期：`alloc → fork → run → exit → wait回收`
3. 实现睡眠/唤醒：基于 channel 的 `sleep/wakeup`
4. 实现抢占式调度：支持优先级与老化机制（boost）
5. 理解上下文切换：`proc_sched()` 与 `swtch.S` 的寄存器保存/恢复

### 1.2 完成情况（结合本工程实现）
- ✅ 进程结构与状态：`include/proc/proc.h` + `kernel/proc/proc.c`
- ✅ 上下文切换：`kernel/proc/swtch.S` 的 `swtch`
- ✅ 调度器：`kernel/proc/proc.c` 的 `proc_scheduler()` + `effective_priority()`
- ✅ 睡眠/唤醒：`proc_sleep()` / `proc_wakeup()`
- ✅ 退出/回收：`proc_exit()` / `proc_wait()`（含 ZOMBIE 回收）

### 1.3 开发环境
- OS：Windows（本机）
- 目标架构：RISC-V 64
- 模拟器：QEMU virt

---

## 二、技术设计

### 2.1 进程状态机
本实验采用经典的进程状态：

### 2.2 关键数据结构：proc_t
`proc_t` 是进程管理的核心，典型字段包括：
- `pid`、`state`、`parent`：标识/状态/父子关系
- `tf`（trapframe）：保存用户态寄存器（系统调用参数与返回值依赖它）
- `ctx`（context）：内核上下文（`swtch` 保存/恢复）
- `killed`：终止标记（与实验6的 `kill` 系统调用直接相关）

### 2.3 调度算法：优先级 + 老化（boost）
本工程实现中存在：
- `effective_priority(p) = p->priority + p->priority_boost`
- 通过周期性增加等待进程的 `priority_boost`，减少饥饿
- 进程被选中运行后，通常会清零或降低 boost

该设计的目标：
- 保证高优先级任务响应更快
- 通过老化机制保证低优先级任务不会永远饿死

---

## 三、实现细节

### 3.1 上下文切换：proc_sched 与 swtch
对应文件：
- `kernel/proc/proc.c`：`proc_sched()`（调度切换入口）
- `kernel/proc/swtch.S`：`swtch(old, new)`（真正的寄存器保存/恢复）

理解要点：
1. `proc_yield()` 会把当前 RUNNING 进程状态改为 RUNNABLE，然后进入 `proc_sched()`
2. `proc_sched()` 调用 `swtch(&p->ctx, &cpu->ctx)`，让 CPU 回到调度器上下文
3. 调度器 `proc_scheduler()` 选择下一个 RUNNABLE 进程，再 `swtch(&cpu->ctx, &chosen->ctx)` 切过去

### 3.2 进程创建与复制：fork
典型链路：
- 用户态 `fork()` → 系统调用 → `proc_fork()`（或同等命名函数）
- 分配新进程结构，复制父进程必要资源（页表/文件/寄存器状态）
- 将子进程标记为 RUNNABLE，等待调度

### 3.3 退出与回收：exit / wait
关键点：
- 子进程调用 `exit` 后进入 ZOMBIE（资源释放一部分，但保留退出码和 pid 供父进程 wait）
- 父进程调用 `wait` 回收子进程，释放进程表槽位（ZOMBIE → UNUSED）

### 3.4 睡眠与唤醒：sleep/wakeup
关键点：
- `sleep(chan, lock)`：原子地释放锁并进入 SLEEPING，等待 `wakeup(chan)`
- `wakeup(chan)`：扫描进程表，将等待该通道的进程设为 RUNNABLE
- `sleep` 与 `wakeup` 是阻塞同步的基础（例如等待 ticks、等待 IO、等待子进程退出）

---

## 四、测试与结果

### 4.1 进程创建与回收
验证点：
- `fork()` 返回值：父进程得到子 pid，子进程得到 0
- `wait()` 能回收子进程，避免出现大量 ZOMBIE

### 4.2 调度公平性与抢占
验证点：
- 多进程并发运行时能够轮转
- 高优先级更容易被选中（如工程提供 priority 设置接口/默认值）
- boost 能避免极端饥饿（长时间不运行的进程最终能被调度到）

---

## 五、实验总结
本实验完成了进程从创建到退出回收的全流程，并实现了可抢占的优先级调度。进程的 `trapframe/context`、状态机、sleep/wakeup 机制为系统调用与异步中断下的正确运行打下基础。

---

# 实验6：系统调用

## 一、实验概述

### 1.1 实验目标
1. 理解系统调用的完整路径：用户态封装 → `ecall` → trap → 分发 → 内核实现 → 返回用户态
2. 搭建系统调用分发表：`SYS_xxx → sys_xxx`
3. 实现典型系统调用：进程类（`getpid/yield/sleep/kill` 等）、文件类（`read/write/open/close` 等）
4. 理解参数传递与返回值规则：RISC-V a0-a7 寄存器约定
5.（补充重点）讲清楚“父进程杀死子进程”的 kill 机制与触发退出点

### 1.2 完成情况（结合本工程实现）
- ✅ `syscall()` 分发器：`kernel/syscall/syscall.c`
- ✅ 系统调用实现：`kernel/syscall/sysfunc.c` + `kernel/syscall/sysfile.c`
- ✅ 用户态封装：`user/syscall_wrap.h`（或同等封装头文件）
- ✅ `sys_kill` + `proc_kill` + trap 检查退出：见本章第 3 节

### 1.3 开发环境
- OS：Windows（本机）
- 目标架构：RISC-V 64
- 模拟器：QEMU virt

---

## 二、技术设计

### 2.1 系统调用完整流程（本工程实际命名）

```
用户态调用 sys_xxx()（user/syscall_wrap.h）
	↓
ecall（a7=系统调用号，a0-a6=参数）
	↓
trap_user_handler()（kernel/trap/trap_user.c）
	- 识别 scause==8
	- sepc += 4 跳过 ecall
	↓
syscall()（kernel/syscall/syscall.c）
	- 读取 a7 作为 syscall 编号
	- 查表调用 sys_xxx
	↓
sys_xxx()（kernel/syscall/sysfunc.c / sysfile.c）
	↓
返回值写回 a0
	↓
trap_user_return() → trampoline → sret
```

### 2.2 系统调用号与分发表
本工程通过头文件定义 `SYS_xxx` 编号，并在 `kernel/syscall/syscall.c` 中建立数组：

```c
static uint64 (*syscalls[])(void) = {
	[SYS_kill] sys_kill,
	// ...
};
```

### 2.3 参数提取与错误处理
系统调用参数来自 trapframe 的 a0-a6：
- `arg_int()` / `arg_uint64()` / `arg_str()` 负责从用户态寄存器/内存中取参
- 失败返回 -1（保持接口简单一致）

---

## 三、实现细节

### 3.1 trap_user_handler：系统调用入口
对应文件：`kernel/trap/trap_user.c`。

关键点：
1. `scause==8` 表示用户态 ecall
2. `p->tf->epc += 4`：跳过 ecall 指令，避免返回后重复陷入
3. `syscall()` 分发
4. 多处 `proc_killed(p)` 检查：保证被 kill 的进程不会再回到用户态继续运行

### 3.2 syscall 分发器：syscall()
对应文件：`kernel/syscall/syscall.c`。

关键点：
- 读取 a7 得到 syscall 编号
- 检查编号合法后查表调用 `syscalls[num]()`
- 将返回值写回 a0

### 3.3 典型系统调用实现：yield / sleep
对应文件：`kernel/syscall/sysfunc.c`。

- `sys_yield()`：让当前进程主动让出 CPU（通常调用 `proc_yield()`）
- `sys_sleep(n)`：睡眠 n ticks；循环中也会检查 `proc_killed(myproc())`，确保 kill 能尽快生效

---

## 四、重点补充：父进程杀死子进程（kill）

这一节按“单实验报告”的写法，完整说明 **kill 的实现、时机与验证方式**。

### 4.1 功能目标
父进程可以通过 `kill(child_pid)` 请求终止子进程；子进程最终会退出并由父进程 `wait()` 回收。

### 4.2 内核实现链路

#### 4.2.1 sys_kill：系统调用入口
对应实现：`kernel/syscall/sysfunc.c`。

逻辑（概括）：
- 从系统调用参数取出 `pid`
- 调用 `proc_kill(pid)`
- 成功返回 0，失败返回 -1

#### 4.2.2 proc_kill：设置 killed 标志并唤醒
对应实现：`kernel/proc/proc.c`。

关键行为：
1. 遍历进程表找到目标 pid
2. 加锁后设置 `p->killed = true`
3. 如果目标进程处于 `SLEEPING`，将其置为 `RUNNABLE`

设计理由：
- 如果不把 SLEEPING 进程唤醒，它可能长期不进内核，自然也就无法检查 killed
- 置为 RUNNABLE 后，调度器会在合适时机让它运行，从而尽快在 trap 点退出

#### 4.2.3 killed 的“真正生效点”：trap_user_handler 退出
对应实现：`kernel/trap/trap_user.c`。

本工程中 kill 的退出点很明确：
- 在用户态 trap 的多个位置检查 `proc_killed(p)`，一旦为真直接 `proc_exit(-1)`

因此 kill 的语义是“**异步生效**”：
- `kill(pid)` 并不是立刻把对方从 CPU 上抹掉，而是设置标志并尽可能唤醒
- 目标进程在**下一次进入内核**时（系统调用/时钟中断/异常）检查 killed 并退出

### 4.3 父杀子测试程序（思路）

```
int pid = fork();

if(pid == 0) {
	// child
	while(1) {
		// 推荐：sleep，覆盖 SLEEPING→RUNNABLE 的 kill 逻辑
		sleep(10);
	}
} else {
	// parent
	sleep(50);
	kill(pid);
	wait(0);
}
```

预期结果：
- 父进程 `kill(pid)` 返回 0
- 子进程在后续某次 trap 检查到 killed，执行 `exit(-1)`
- 父进程 `wait()` 成功回收子进程，避免 ZOMBIE 残留

---

## 五、实验总结
本实验实现了从用户态 `ecall` 到内核态服务的完整系统调用框架，并补充验证了 `kill` 这一典型进程控制系统调用：通过 `killed` 标志 + trap 检查点实现异步终止，并配合 `wait()` 完成父进程回收。

