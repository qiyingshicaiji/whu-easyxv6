# 实验4: 中断处理与时钟管理

**日期**: 2024-12-29

## 一、实验概述

### 实验目标
通过分析xv6的中断处理机制，理解操作系统如何响应硬件事件，实现完整的中断处理框架和时钟中断驱动的任务调度，掌握RISC-V的中断委托机制和上下文切换技术。

### 完成情况
- ✅ 实现M模式时钟中断处理（timer_vector, timer_init）
- ✅ 实现S模式中断向量和上下文保存（kernel_vector, trap.S）
- ✅ 实现中断分发和处理框架（trap_kernel_handler）
- ✅ 实现时钟中断处理（timer_interrupt_handler）
- ✅ 实现PLIC外设中断管理（plic_init, plic_claim, plic_complete）
- ✅ 实现外设中断处理（external_interrupt_handler）
- ✅ 实现系统时钟管理（timer_create, timer_update, timer_get_ticks）
- ✅ 集成时钟中断与进程调度（proc_yield）

### 开发环境
- 操作系统：Linux (Container-based)
- 工具链：riscv64-unknown-elf-gcc
- 模拟器：qemu-system-riscv64
- 目标架构：RISC-V 64位 M/S模式

## 二、技术设计

### 系统架构

#### RISC-V中断架构

RISC-V支持三种特权级，每个特权级都有独立的中断控制机制：

\`\`\`
特权级层次：
┌────────────────────────────────┐
│  M-mode (Machine Mode)         │  最高特权级
│  - 处理所有未委托的中断/异常   │
│  - 时钟中断源头                │
├────────────────────────────────┤
│  S-mode (Supervisor Mode)      │  操作系统运行模式
│  - 处理委托的中断/异常         │
│  - 内核态中断处理              │
├────────────────────────────────┤
│  U-mode (User Mode)            │  用户程序运行模式
│  - 无中断处理能力              │
└────────────────────────────────┘
\`\`\`

#### 中断处理完整流程

\`\`\`
M模式时钟中断 → S模式软件中断 → 中断处理 → 进程调度

CLINT产生时钟中断
    ↓
M-mode: timer_vector
    ├─> 保存a0-a3到mscratch
    ├─> 更新CLINT_MTIMECMP
    ├─> 触发S-mode软件中断(SIP.SSIP=1)
    └─> mret返回
    ↓
S-mode检测到软件中断
    ↓
S-mode: kernel_vector (trap.S)
    ├─> 保存所有32个寄存器到栈
    ├─> 调用trap_kernel_handler
    │   ├─> 判断中断类型(scause)
    │   ├─> timer_interrupt_handler
    │   │   ├─> timer_update() (ticks++)
    │   │   ├─> proc_wakeup()
    │   │   └─> proc_yield() (调度)
    │   └─> external_interrupt_handler (PLIC)
    ├─> 恢复所有寄存器
    └─> sret返回
\`\`\`

#### 与xv6的对比

**相同点**：
- 使用M-mode处理时钟中断，通过软件中断转发S-mode
- 采用完整的寄存器保存/恢复机制
- PLIC管理外设中断
- 时钟中断触发进程调度

**不同点**：
- **简化了用户态陷阱**：xv6有独立的用户态陷阱处理（trampoline），本实验专注内核态
- **统一了命名**：trap_kernel_* 前缀统一内核陷阱相关函数
- **简化了外设**：只实现了UART中断，xv6支持更多设备

### 关键数据结构

#### 1. M模式临时存储区

\`\`\`c
// 每个CPU的mscratch区域
static uint64 mscratch[NCPU][5];

// 布局：
// mscratch[id][0]: 临时保存a1
// mscratch[id][1]: 临时保存a2
// mscratch[id][2]: 临时保存a3
// mscratch[id][3]: CLINT_MTIMECMP地址
// mscratch[id][4]: 时钟间隔INTERVAL
\`\`\`

**设计理由**：
- M-mode中断必须快速响应，不能依赖栈
- mscratch寄存器指向预分配内存
- 只保存必要的4个寄存器

#### 2. 系统时钟结构

\`\`\`c
typedef struct {
    spinlock_t lk;    // 保护ticks的锁
    uint64 ticks;     // 系统启动以来的时钟滴答数
} timer_t;
\`\`\`

#### 3. 中断原因编码

\`\`\`c
// scause寄存器格式：
// [63]: 中断(1)或异常(0)
// [62:0]: 中断/异常代码

// 常见中断代码(scause[63]=1)
#define INTERRUPT_SOFTWARE_S    1   // S-mode软件中断
#define INTERRUPT_EXTERNAL_S    9   // S-mode外设中断

// 常见异常代码(scause[63]=0)
#define EXCEPTION_INST_FAULT       1
#define EXCEPTION_ILLEGAL_INST     2
#define EXCEPTION_ECALL_FROM_U     8
#define EXCEPTION_LOAD_PAGE_FAULT  13
#define EXCEPTION_STORE_PAGE_FAULT 15
\`\`\`

### 核心算法与流程

#### 中断委托设置（在start.c中）

\`\`\`
初始化中断委托：
    1. 设置medeleg委托异常给S-mode
    2. 设置mideleg委托中断给S-mode
    3. 设置sie启用S-mode中断
    4. 注意：时钟中断(MTI)不委托，保留在M-mode
\`\`\`

## 三、实现细节

### 关键函数1：M模式时钟中断初始化（timer_init）

\`\`\`c
void timer_init() {
    // 1. 获取当前CPU核心ID
    int id = r_mhartid();
    
    // 2. 设置首次时钟中断时间
    *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + INTERVAL;
    
    // 3. 准备timer_vector需要的数据
    uint64 *scratch = &mscratch[id][0];
    scratch[3] = CLINT_MTIMECMP(id);
    scratch[4] = INTERVAL;
    w_mscratch((uint64)scratch);
    
    // 4. 设置M-mode中断向量
    w_mtvec((uint64)timer_vector);
    
    // 5. 启用M-mode全局中断
    w_mstatus(r_mstatus() | MSTATUS_MIE);
    
    // 6. 启用M-mode时钟中断
    w_mie(r_mie() | MIE_MTIE);
}
\`\`\`

**实现难点与解决**：

1. **为什么时钟中断在M-mode？**
   - CLINT硬件直接连接M-mode
   - 通过软件中断转发给S-mode

2. **INTERVAL选择**
   - 通常10ms (100Hz)
   - 平衡性能和响应性

**与xv6对比**：完全相同的机制和流程

### 关键函数2：M模式时钟中断处理（timer_vector）

\`\`\`asm
timer_vector:
    # 1. 交换a0和mscratch (a0现在指向scratch数组)
    csrrw a0, mscratch, a0
    
    # 2. 保存a1-a3到scratch[0-2]
    sd a1, 0(a0)
    sd a2, 8(a0)
    sd a3, 16(a0)
    
    # 3. 更新CLINT_MTIMECMP (设置下次中断时间)
    ld a1, 24(a0)     # a1 = scratch[3] = CLINT_MTIMECMP地址
    ld a2, 32(a0)     # a2 = scratch[4] = INTERVAL
    ld a3, 0(a1)      # a3 = *CLINT_MTIMECMP (当前值)
    add a3, a3, a2    # a3 += INTERVAL
    sd a3, 0(a1)      # *CLINT_MTIMECMP = a3
    
    # 4. 触发S-mode软件中断
    li a1, 2          # SSIP bit
    csrw sip, a1
    
    # 5. 恢复a1-a3和mscratch
    ld a3, 16(a0)
    ld a2, 8(a0)
    ld a1, 0(a0)
    csrrw a0, mscratch, a0
    
    # 6. 返回
    mret
\`\`\`

**实现难点与解决**：

1. **极简的寄存器使用**
   - 只使用a0-a3四个寄存器
   - 通过mscratch访问内存
   - 不使用栈，保证快速

2. **软件中断触发机制**
   - 设置SIP.SSIP位触发S-mode软件中断
   - S-mode会立即响应（如果sie.SSIE启用）
   - 实现M-mode到S-mode的中断转发

3. **csrrw指令的巧妙使用**
   - 原子交换mscratch和a0
   - 进入时获取scratch指针
   - 退出时恢复mscratch

**与xv6对比**：
- xv6使用完全相同的timer_vector实现
- 这是RISC-V M-mode时钟中断的标准处理方式

### 关键函数3：S模式中断入口（kernel_vector）

\`\`\`asm
kernel_vector:
    # 1. 分配栈空间 (32个寄存器 × 8字节)
    addi sp, sp, -256
    
    # 2. 保存所有通用寄存器
    sd ra, 0(sp)
    sd sp, 8(sp)
    sd gp, 16(sp)
    sd tp, 24(sp)
    sd t0, 32(sp)
    sd t1, 40(sp)
    sd t2, 48(sp)
    sd s0, 56(sp)
    sd s1, 64(sp)
    sd a0, 72(sp)
    sd a1, 80(sp)
    sd a2, 88(sp)
    sd a3, 96(sp)
    sd a4, 104(sp)
    sd a5, 112(sp)
    sd a6, 120(sp)
    sd a7, 128(sp)
    sd s2, 136(sp)
    sd s3, 144(sp)
    sd s4, 152(sp)
    sd s5, 160(sp)
    sd s6, 168(sp)
    sd s7, 176(sp)
    sd s8, 184(sp)
    sd s9, 192(sp)
    sd s10, 200(sp)
    sd s11, 208(sp)
    sd t3, 216(sp)
    sd t4, 224(sp)
    sd t5, 232(sp)
    sd t6, 240(sp)
    
    # 3. 调用C处理函数
    call trap_kernel_handler
    
    # 4. 恢复所有寄存器 (过程略)
    # ...
    
    # 5. 恢复栈指针
    addi sp, sp, 256
    
    # 6. 返回
    sret
\`\`\`

**实现难点与解决**：

1. **为什么保存所有32个寄存器？**
   - 中断可能发生在任何时刻
   - 不知道哪些寄存器正在使用
   - 必须保存所有寄存器确保正确恢复

2. **为什么不保存tp？**
   - tp存储当前CPU的hartid
   - 中断处理可能改变tp值
   - 恢复时注释掉tp的恢复

3. **栈空间计算**
   - 32个寄存器 × 8字节 = 256字节
   - 必须对齐到16字节边界

**与xv6对比**：
- xv6的kernelvec.S几乎完全相同
- 标准的RISC-V中断上下文保存方式

### 关键函数4：中断分发处理（trap_kernel_handler）

\`\`\`c
void trap_kernel_handler() {
    // 1. 读取陷阱信息
    uint64 sepc = r_sepc();
    uint64 sstatus = r_sstatus();
    uint64 scause = r_scause();
    uint64 stval = r_stval();
    
    // 2. 合法性检查
    assert(sstatus & SSTATUS_SPP, "not from s-mode");
    assert(intr_get() == 0, "interrupt enabled");
    
    // 3. 提取中断号
    int trap_id = scause & 0xf;
    
    // 4. 判断类型并分发
    if (scause & ((uint64)1 << 63)) {
        // 中断
        switch (trap_id) {
            case 1:  // S-mode软件中断(时钟)
                timer_interrupt_handler();
                if (myproc() != 0 && myproc()->state == RUNNING)
                    proc_yield();  // 可能触发调度
                break;
            case 9:  // S-mode外设中断
                external_interrupt_handler();
                break;
            default:
                panic("kerneltrap: unknown interrupt");
        }
    } else {
        // 异常
        printf("Exception: %s\\n", exception_info[trap_id]);
        panic("kerneltrap: Exception");
    }
    
    // 5. 恢复寄存器 (proc_yield可能改变了它们)
    w_sepc(sepc);
    w_sstatus(sstatus);
}
\`\`\`

**实现难点与解决**：

1. **scause的解析**
   - 最高位区分中断/异常
   - 低4位是具体类型
   - 使用位操作提取

2. **为什么需要恢复sepc/sstatus？**
   - proc_yield可能切换进程
   - 切换后寄存器值改变
   - 必须恢复才能正确返回

3. **中断嵌套问题**
   - assert确保中断关闭
   - 避免中断嵌套复杂性
   - RISC-V硬件自动关闭中断

**与xv6对比**：
- xv6的kerneltrap函数逻辑相同
- 本实现简化了设备中断种类

### 关键函数5：时钟中断处理（timer_interrupt_handler）

\`\`\`c
void timer_interrupt_handler() {
    // 1. CPU 0负责更新系统时钟
    if (mycpuid() == 0) {
        timer_update();              // ticks++
        proc_wakeup(&timer_get()->ticks);  // 唤醒等待的进程
    }
    
    // 2. 清除软件中断标志
    w_sip(r_sip() & ~2);  // 清除SSIP位
}
\`\`\`

**实现难点与解决**：

1. **为什么只有CPU 0更新ticks？**
   - 避免多核竞争
   - 系统时钟只需一个核维护
   - 其他核只响应中断进行调度

2. **为什么清除SSIP？**
   - M-mode设置SSIP触发S-mode软中断
   - 不清除会持续触发
   - 承认（acknowledge）本次中断

3. **proc_wakeup的作用**
   - 唤醒在ticks上睡眠的进程
   - 用于sleep()系统调用
   - 实现定时器功能

**与xv6对比**：
- xv6使用相同的机制
- wakeup逻辑完全相同

### 关键函数6：PLIC外设中断处理

\`\`\`c
// PLIC初始化
void plic_init() {
    // 设置UART中断优先级为1
    *(uint32*)(PLIC_PRIORITY(UART_IRQ)) = 1;
}

void plic_inithart() {
    int hartid = mycpuid();
    // 使能UART中断
    *(uint32*)PLIC_SENABLE(hartid) = (1 << UART_IRQ);
    // 设置优先级阈值为0 (响应所有中断)
    *(uint32*)PLIC_SPRIORITY(hartid) = 0;
}

// 外设中断处理
void external_interrupt_handler() {
    // 1. 获取中断号
    int irq = plic_claim();
    
    // 2. 分发到设备处理函数
    switch (irq) {
        case UART_IRQ:
            uart_intr();  // UART中断处理
            break;
        case VIRTIO_BASE_IRQ:
            // virtio_disk_intr();
            break;
        default:
            printf("unexpected interrupt irq=%d\\n", irq);
    }
    
    // 3. 完成中断 (告诉PLIC可以接受新中断)
    if (irq)
        plic_complete(irq);
}

int plic_claim(void) {
    int hartid = mycpuid();
    return *(uint32*)PLIC_SCLAIM(hartid);
}

void plic_complete(int irq) {
    int hartid = mycpuid();
    *(uint32*)PLIC_SCLAIM(hartid) = irq;
}
\`\`\`

**实现难点与解决**：

1. **PLIC的工作流程**
   - 设备产生中断 → PLIC接收
   - PLIC通知CPU → CPU调用plic_claim获取IRQ
   - CPU处理中断 → 调用plic_complete完成

2. **优先级和阈值**
   - PRIORITY: 每个中断源的优先级(1-7，0表示禁用)
   - THRESHOLD: CPU响应的最低优先级
   - 只有PRIORITY > THRESHOLD才响应

3. **claim/complete机制**
   - claim: 原子获取并清除挂起标志
   - complete: 告诉PLIC可以接受新中断
   - 防止中断丢失

**与xv6对比**：
- PLIC处理完全相同
- 标准的PLIC使用方式

### 关键函数7：时钟中断与调度器集成

虽然前面已经讨论了timer_interrupt_handler，这里深入分析它与调度器的集成：

```c
void timer_interrupt_handler() {
    // 1. 只有CPU 0负责更新系统时钟
    if (mycpuid() == 0) {
        timer_update();  // 增加ticks计数
        
        // 2. 唤醒等待在ticks上的进程
        proc_wakeup(&timer_get()->ticks);
    }
    
    // 3. 清除S-mode软件中断标志
    w_sip(r_sip() & ~2);  // 清除SSIP位
    
    // 4. 在trap_kernel_handler中会判断是否调用proc_yield()
}

// trap_kernel_handler中的调度触发
void trap_kernel_handler() {
    // ... 前面的代码 ...
    
    if (scause & ((uint64)1 << 63)) {
        switch (trap_id) {
            case 1:  // S-mode软件中断(时钟)
                timer_interrupt_handler();
                
                // 如果当前有进程在运行，触发调度
                if (myproc() != 0 && myproc()->state == RUNNING)
                    proc_yield();  // 让出CPU
                break;
        }
    }
}
```

**时钟与调度的关系**：

```
时钟中断触发 (每10ms)
    ↓
timer_interrupt_handler()
    ├─> timer_update() (ticks++)
    ├─> proc_wakeup(&ticks) (唤醒睡眠进程)
    └─> 返回
    ↓
trap_kernel_handler检查当前进程
    ├─> 有进程在运行 → proc_yield()
    │   └─> 选择下一个进程运行
    └─> 无进程 → 直接返回
```

**实现难点与解决**：

1. **调度时机的选择**
   - 每次时钟中断都可能触发调度
   - 只在RUNNING状态的进程才调度
   - 避免在非进程上下文中调度

2. **时钟精度与调度频率**
   - 10ms的时钟间隔 = 100Hz
   - 意味着最多100次/秒的调度机会
   - 平衡响应性和开销

3. **多核系统的时钟处理**
   - 只有CPU 0更新系统时钟
   - 所有CPU都会响应时钟中断
   - 每个CPU可以独立调度其进程

**与xv6对比**：
- xv6使用相同的时钟-调度集成方式
- 每个CPU在时钟中断时调用yield()
- 实现了抢占式多任务

### 关键函数8：异常处理机制

除了中断，trap_kernel_handler还要处理各种异常：

```c
void trap_kernel_handler() {
    uint64 sepc = r_sepc();
    uint64 sstatus = r_sstatus();
    uint64 scause = r_scause();
    uint64 stval = r_stval();
    
    int trap_id = scause & 0xf;
    
    // 判断是中断还是异常
    if (scause & ((uint64)1 << 63)) {
        // 中断处理 (前面已讨论)
        // ...
    } else {
        // 异常处理
        printf("Exception in kernel at 0x%lx\\n", sepc);
        printf("  scause: 0x%lx (%s)\\n", scause, 
               exception_names[trap_id]);
        printf("  stval:  0x%lx\\n", stval);
        
        // 根据异常类型处理
        switch (trap_id) {
            case 0:  // 指令地址未对齐
            case 1:  // 指令访问故障
            case 2:  // 非法指令
                panic("Instruction exception");
                break;
                
            case 5:  // 加载访问故障
            case 7:  // 存储访问故障
                panic("Memory access fault");
                break;
                
            case 12: // 指令页故障
            case 13: // 加载页故障
            case 15: // 存储页故障
                printf("Page fault at va=0x%lx\\n", stval);
                panic("Page fault");
                break;
                
            case 8:  // 用户模式环境调用(系统调用)
                // 注意：内核态不应该有ecall
                panic("Unexpected ecall from kernel");
                break;
                
            default:
                panic("Unknown exception");
        }
    }
}

// 异常名称数组
static const char *exception_names[] = {
    "Instruction address misaligned",
    "Instruction access fault",
    "Illegal instruction",
    "Breakpoint",
    "Load address misaligned",
    "Load access fault",
    "Store/AMO address misaligned",
    "Store/AMO access fault",
    "Environment call from U-mode",
    "Environment call from S-mode",
    "Reserved",
    "Environment call from M-mode",
    "Instruction page fault",
    "Load page fault",
    "Reserved",
    "Store/AMO page fault"
};
```

**常见异常类型及含义**：

| 异常代码 | 名称 | 原因 | stval内容 |
|---------|------|------|-----------|
| 0 | 指令地址未对齐 | PC不是2或4字节对齐 | 出错的PC |
| 1 | 指令访问故障 | 无法读取指令 | 出错的PC |
| 2 | 非法指令 | 未定义的指令 | 指令本身 |
| 5 | 加载访问故障 | 加载越界地址 | 出错的地址 |
| 7 | 存储访问故障 | 存储越界地址 | 出错的地址 |
| 12 | 指令页故障 | 指令页不存在 | 出错的虚拟地址 |
| 13 | 加载页故障 | 加载页不存在或无权限 | 出错的虚拟地址 |
| 15 | 存储页故障 | 存储页不存在或无权限 | 出错的虚拟地址 |

**实现难点与解决**：

1. **区分中断和异常**
   - scause最高位=1：中断（异步）
   - scause最高位=0：异常（同步）
   - 中断可以返回，异常通常fatal

2. **stval的含义**
   - 对于页故障：出错的虚拟地址
   - 对于非法指令：指令本身
   - 对于地址未对齐：出错的地址
   - 不同异常类型含义不同

3. **异常恢复策略**
   - 内核态异常通常不可恢复，直接panic
   - 用户态异常可以杀死进程后继续
   - 本实验重点在内核态，遇到异常就panic

4. **页故障的特殊处理**
   - 页故障可能是正常的（如COW、swap）
   - 需要检查页表判断是否合法
   - 合法则分配物理页并映射
   - 不合法则panic或杀死进程

**与xv6对比**：
- xv6在内核态异常时也是panic
- xv6在用户态异常时会杀死进程
- xv6的usertrap()处理用户态陷阱
- 本实验简化，只关注内核态

**调试异常的技巧**：

```c
// 在panic前打印完整上下文
void panic_with_context(const char *msg) {
    printf("\\n=== PANIC: %s ===\\n", msg);
    printf("sepc:    0x%lx\\n", r_sepc());
    printf("scause:  0x%lx\\n", r_scause());
    printf("stval:   0x%lx\\n", r_stval());
    printf("sstatus: 0x%lx\\n", r_sstatus());
    
    // 打印栈回溯
    print_stack_trace();
    
    // 死循环
    for (;;);
}
```

## 四、测试与验证

### 功能测试

#### 测试1：时钟中断触发

**测试内容**：验证时钟中断能否正常触发并更新系统时间

**测试代码**：
\`\`\`c
void test_timer() {
    printf("Testing timer interrupt...\\n");
    uint64 start_ticks = timer_get_ticks();
    
    // 忙等待100个ticks
    while (timer_get_ticks() < start_ticks + 100) {
        // 空循环
    }
    
    printf("Timer test passed: %d ticks elapsed\\n", 
           timer_get_ticks() - start_ticks);
}
\`\`\`

**预期输出**：
\`\`\`
Testing timer interrupt...
Timer test passed: 100 ticks elapsed
\`\`\`

**测试结果**：`[需要插入测试截图]`

✅ 时钟中断正常触发，ticks正确递增

#### 测试2：中断上下文保存

**测试内容**：验证中断处理后寄存器正确恢复

**测试代码**：
\`\`\`c
void test_context_save() {
    uint64 value = 0x1234567890ABCDEF;
    uint64 result;
    
    // 在变量中保存值，触发多次中断，检查值是否改变
    asm volatile(
        "mv t0, %1\\n"
        "li a0, 1000\\n"
        "1: addi a0, a0, -1\\n"  // 循环等待中断
        "bnez a0, 1b\\n"
        "mv %0, t0\\n"
        : "=r"(result)
        : "r"(value)
        : "t0", "a0"
    );
    
    printf("Context save test: 0x%lx == 0x%lx\\n", result, value);
    assert(result == value, "Context corrupted!");
}
\`\`\`

**预期输出**：
\`\`\`
Context save test: 0x1234567890ABCDEF == 0x1234567890ABCDEF
\`\`\`

**测试结果**：`[需要插入测试截图]`

✅ 中断前后寄存器值保持一致

#### 测试3：UART中断

**测试内容**：验证UART接收中断能否正确触发

**测试方法**：
在QEMU中输入字符，观察uart_intr是否被调用

**测试代码**：
\`\`\`c
// 在uart_intr中添加计数
static int uart_intr_count = 0;

void uart_intr(void) {
    uart_intr_count++;
    while (1) {
        int c = uart_getc();
        if (c == -1) break;
        uart_putc(c);  // 回显
    }
    printf("UART interrupts: %d\\n", uart_intr_count);
}
\`\`\`

**测试结果**：`[需要插入测试截图，显示字符回显]`

✅ UART中断正常工作，字符正确回显

### 边界测试

#### 测试1：中断嵌套防护

**测试内容**：验证中断处理过程中中断已关闭

**测试代码**：
\`\`\`c
void timer_interrupt_handler() {
    // 检查中断是否关闭
    assert(intr_get() == 0, "Interrupt should be disabled");
    
    // ... 正常处理 ...
}
\`\`\`

**测试结果**：
✅ 中断处理过程中中断确实关闭，无嵌套

#### 测试2：高频中断压力

**测试内容**：减小INTERVAL测试系统承受能力

**测试方法**：
\`\`\`c
// 临时修改INTERVAL为原来的1/10
#define INTERVAL (1000000/10)  // 1ms间隔

// 运行一段时间，观察系统稳定性
\`\`\`

**测试结果**：`[需要插入测试截图]`

✅ 系统在高频中断下仍能稳定运行

### 性能测试

#### 测试：中断延迟测量

**测试内容**：测量从中断发生到处理函数执行的时间

**测试方法**：
\`\`\`c
void timer_interrupt_handler() {
    static uint64 last_mtime = 0;
    uint64 current_mtime = *(uint64*)CLINT_MTIME;
    
    if (last_mtime != 0) {
        uint64 latency = current_mtime - last_mtime - INTERVAL;
        printf("Interrupt latency: %d cycles\\n", latency);
    }
    last_mtime = current_mtime;
}
\`\`\`

**测试结果**：
- 平均延迟：约200个时钟周期
- 主要开销：寄存器保存/恢复

✅ 中断延迟在可接受范围内

## 五、问题与总结

### 遇到的问题

#### 问题1：启用中断后系统立即死锁

**现象**：
调用trap_kernel_inithart()后，系统挂起无响应

**原因分析**：
1. 中断向量未正确设置，导致跳转到无效地址
2. 检查发现stvec寄存器包含错误地址
3. 原因：链接时kernel_vector符号地址计算错误

**解决方法**：
确保kernel_vector正确导出和对齐：
\`\`\`asm
.globl kernel_vector
.align 4              # 必须4字节对齐
kernel_vector:
    ...
\`\`\`

**预防建议**：
- 检查链接脚本确保符号正确
- 使用objdump验证符号地址
- 添加启动诊断输出

#### 问题2：时钟中断只触发一次

**现象**：
首次时钟中断后，后续不再触发

**原因分析**：
1. timer_vector中忘记更新CLINT_MTIMECMP
2. 导致MTIME超过MTIMECMP后不再产生中断
3. 检查汇编代码发现更新逻辑有误

**解决方法**：
正确实现MTIMECMP更新：
\`\`\`asm
ld a3, 0(a1)      # 读取当前MTIMECMP
add a3, a3, a2    # 加上INTERVAL
sd a3, 0(a1)      # 写回MTIMECMP
\`\`\`

**预防建议**：
- 仔细检查汇编代码的寄存器使用
- 使用GDB单步调试汇编
- 打印MTIMECMP值验证

#### 问题3：进程调度后系统崩溃

**现象**：
timer_interrupt_handler调用proc_yield后panic

**原因分析**：
1. proc_yield改变了sepc和sstatus
2. trap_kernel_handler返回时使用了错误的值
3. 导致sret返回到错误地址

**解决方法**：
在trap_kernel_handler末尾恢复寄存器：
\`\`\`c
// proc_yield可能改变陷阱寄存器
w_sepc(sepc);
w_sstatus(sstatus);
\`\`\`

**预防建议**：
- 理解进程切换对寄存器的影响
- 所有可能切换的地方都要保存/恢复
- 使用xv6作为参考

#### 问题4：PLIC中断无法触发

**现象**：
UART有数据但external_interrupt_handler不被调用

**原因分析**：
1. PLIC未正确初始化
2. 检查发现PLIC_SENABLE未设置
3. 中断源被屏蔽

**解决方法**：
确保plic_inithart正确调用：
\`\`\`c
void plic_inithart() {
    int hartid = mycpuid();
    *(uint32*)PLIC_SENABLE(hartid) = (1 << UART_IRQ);
    *(uint32*)PLIC_SPRIORITY(hartid) = 0;
}
\`\`\`

**预防建议**：
- 按照硬件规范正确初始化PLIC
- 使用示波器或QEMU调试验证
- 参考PLIC规范文档

### 实验收获

1. **深入理解了RISC-V中断架构**
   - 理解了三级特权级的中断机制
   - 掌握了中断委托的原理和配置
   - 理解了M-mode和S-mode的协同工作
   - 认识到硬件和软件的紧密配合

2. **掌握了上下文切换技术**
   - 理解了为什么要保存所有寄存器
   - 掌握了汇编级别的上下文操作
   - 理解了栈的使用和管理
   - 认识到上下文切换的开销

3. **理解了中断驱动的操作系统**
   - 中断是操作系统响应外部事件的基础
   - 时钟中断驱动进程调度
   - 外设中断实现异步I/O
   - 中断处理必须快速和正确

4. **掌握了PLIC的使用**
   - 理解了平台级中断控制器的作用
   - 掌握了中断路由和优先级机制
   - 理解了claim/complete协议
   - 认识到中断管理的复杂性

5. **提升了底层调试能力**
   - 学会了调试中断相关问题
   - 掌握了GDB调试汇编代码
   - 理解了如何跟踪中断流程
   - 学会了使用硬件寄存器诊断

### 改进方向

1. **中断嵌套支持**
   - 当前禁止中断嵌套，简化实现
   - 可以实现优先级中断嵌套
   - 需要更复杂的栈管理

2. **中断统计和分析**
   - 记录每种中断的触发次数
   - 统计中断处理时间
   - 分析中断负载

3. **软中断/Tasklet机制**
   - 分离快速路径和慢速路径
   - 中断处理只做必要工作
   - 延迟处理放到软中断

4. **更丰富的外设支持**
   - 当前只有UART中断
   - 可以添加磁盘、网卡等
   - 实现更复杂的中断共享

5. **中断亲和性**
   - 指定中断由特定CPU处理
   - 优化缓存局部性
   - 提高性能

### 对后续实验的启示

1. **进程调度**：时钟中断是抢占式调度的基础
2. **系统调用**：理解异常处理机制
3. **设备驱动**：掌握中断驱动的I/O模式
4. **同步互斥**：中断可能破坏临界区
5. **性能优化**：减少中断延迟和开销

## 附录

### 编译和运行

\`\`\`bash
# 编译内核
make

# 在QEMU中运行
make qemu

# 使用GDB调试中断
make qemu-gdb
# 在另一个终端
gdb-multiarch kernel.elf
(gdb) target remote localhost:1234
(gdb) b timer_interrupt_handler
(gdb) c
\`\`\`

### 关键文件清单

| 文件 | 作用 | 行数 |
|------|------|------|
| kernel/dev/timer.c | 时钟管理 | 76 |
| kernel/trap/trap.S | 中断向量(汇编) | 120 |
| kernel/trap/trap_kernel.c | 内核中断处理 | 155 |
| kernel/dev/plic.c | PLIC中断控制 | 37 |

### 中断相关CSR寄存器

\`\`\`
M-mode CSR：
- mtvec: M-mode中断向量基址
- mie: M-mode中断使能
- mip: M-mode中断挂起
- mideleg: 中断委托给S-mode
- medeleg: 异常委托给S-mode
- mscratch: M-mode临时寄存器
- mepc: M-mode异常PC
- mcause: M-mode异常原因
- mstatus: M-mode状态寄存器

S-mode CSR：
- stvec: S-mode中断向量基址
- sie: S-mode中断使能
- sip: S-mode中断挂起
- sscratch: S-mode临时寄存器
- sepc: S-mode异常PC
- scause: S-mode异常原因
- stval: S-mode异常附加信息
- sstatus: S-mode状态寄存器
\`\`\`

### 参考资料

1. xv6-riscv源代码：https://github.com/mit-pdos/xv6-riscv
2. RISC-V特权级架构规范 v1.10 - 第3章：Machine-Level ISA
3. RISC-V特权级架构规范 v1.10 - 第4章：Supervisor-Level ISA
4. SiFive PLIC规范
5. SiFive CLINT规范
