# 《操作系统实践A》实验报告

| 实验名称 | **实验三：页表与内存管理** |
| :--- | :--- |
| 学院 | 计算机学院 |
| 专业 | 计算机科学与技术 |
| 班级 | 计算机类15班 |
| 学号 | 2023305231024 |
| 姓名 | 蒋志豪 |
| 日期 | 2025/10/13 |

---

## 摘要

本次实验目标是理解 RISC-V Sv39 虚拟内存机制，并独立实现**物理内存分配器 (PMM)** 和**页表管理系统**。我们通过模拟 xv6 的设计，实现了基于空闲页链表的物理页分配和释放机制。随后，我们实现了三级页表遍历、映射建立的核心功能，并最终完成了内核空间的恒等映射，成功开启了 RISC-V 的分页机制，为多进程和内存保护奠定基础。

**关键词**: `虚拟内存`, `RISC-V`, `Sv39`, `页表`, `物理内存分配器`, `恒等映射`, `kalloc`

---

## 1. 系统设计与实现

### 1.1 物理内存分配器 (PMM) 设计

我们采用类似 xv6 的**空闲页链表**方案来实现物理内存分配器 (`kalloc.c`)。
1.  **数据结构**: 利用待分配的物理页本身的内存空间来存储链表指针 (`struct run { struct run *next; }`)。这种设计巧妙地**避免了额外的元数据存储空间**，分配和释放操作时间复杂度为 $O(1)$。
2.  **初始化 (`kinit`)**: 从内核代码结束地址 (`etext`) 之后到内存上限 (`PHYSTOP`)，将所有可用的物理页按页大小 (4KB) 拆分，并通过 `kfree()` 函数连接到空闲链表的头部。

### 1.2 页表管理系统设计

我们基于 RISC-V 的 **Sv39** 模式实现虚拟内存管理 (`vm.c`)。

1.  **地址解析**: 39 位虚拟地址被分解为 3 个 9 位的 VPN (Virtual Page Number) 索引和 12 位的页内偏移 (offset)。
2.  **页表遍历 (`walk`)**: 递归遍历三级页表结构。如果中间级的页表项无效 (`PTE_V` 未设置)，并且需要分配新的页表 (`alloc=1`)，则调用 `kalloc` 分配一个新的物理页作为下一级页表，并设置该 PTE 的 `PTE_V` 位。
3.  **映射建立 (`map_page`)**: 在 `walk` 成功返回叶子节点 PTE 后，将物理地址 (PA) 转换为 PTE 格式并与权限位 (PTE\_R/W/X) 和有效位 (PTE\_V) 按位或，写入 PTE。

### 1.3 虚拟内存激活

1.  **内核映射**: 在 `kvminit()` 中，我们为内核代码段、数据段和必要的设备（如 UART）建立了**恒等映射**，即虚拟地址等于物理地址。
2.  **激活**: 在 `kvminithart()` 中，通过将内核页表的物理页号写入 **SATP 寄存器**，并设置 Sv39 模式，**启用分页机制**。
3.  **TLB 刷新**: 使用 `sfence.vma` 指令刷新 TLB，确保 CPU 使用新的页表进行地址转换。

---

## 2. 思考题与解答

### 2.1 Sv39 页表机制思考

1.  **为什么选择三级页表而不是二级或四级？**
    三级页表 (Sv39) 是 RISC-V 架构在 64 位下为 39 位虚拟地址空间选择的平衡方案。它在**空间效率**和**查找速度**之间取得了平衡。如果使用二级页表，则每一级页表需要更大的索引空间，导致页表自身占用的空间变大；如果使用四级页表，查找的深度增加，会增加页表查找的开销。三级页表结构可以有效地覆盖 $2^{39}$ 的虚拟地址空间，同时保持页表项 (PTE) 的数量合理。

2.  **中间级页表项的 R/W/X 位应该如何设置？**
    中间级页表项（Level 1 和 Level 2）**不应设置** R、W 或 X 权限位。这些位只有在**叶子节点**（Level 0，指向最终物理页面的页表项）上才有意义。如果中间级 PTE 设置了 R/W/X 权限位，CPU 会将其视为一个**大页映射**（Superpage），直接进行地址转换，跳过剩余的页表级数。

### 2.2 物理内存分配器思考

1.  **xv6 物理内存分配器设计的巧妙之处和不足是什么？**
    * **巧妙之处**: 使用**空闲页链表**，将链表节点 (`struct run`) 直接嵌入到空闲的物理页头部。这避免了为管理元数据而进行额外的内存分配，结构简单，且分配/释放操作的时间复杂度是 $O(1)$。
    * **不足**: 这种设计容易产生**外部碎片**（External Fragmentation），因为它只能分配固定大小的页面（4KB）。此外，它不支持并发访问，需要额外的锁机制来保证**线程安全**。

2.  **如何防止 Double-Free（重复释放）？**
    防止 Double-Free 的简单方法是在 `kfree()` 函数中，对释放的页面进行**内存清零（例如写入一个特定的非零魔数）**。当一个页面被释放时，其内容通常会被擦除。如果在程序尝试第二次释放该页面时，检查该页面头部是否已经包含了预设的魔数，就可以检测出重复释放行为。