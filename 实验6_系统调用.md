# 实验6：系统调用

**实验日期**：2024-XX-XX

## 一、实验概述

### 实验目标

通过深入分析xv6的系统调用机制，理解用户态与内核态的交互方式，实现完整的系统调用框架和常用系统调用功能，掌握操作系统如何为用户程序提供受控的内核服务访问接口。

### 完成情况

- ✅ **任务1**：理解系统调用的实现原理（完整流程、ecall机制、特权级切换）
- ✅ **任务2**：分析xv6的系统调用分发机制（syscall分发器、参数提取、用户内存访问）
- ✅ **任务3**：设计系统调用框架（系统调用表、参数传递、错误处理）
- ✅ **任务4**：实现基础系统调用（fork、exit、wait、getpid等进程管理）
- ✅ **任务5**：实现文件系统调用（open、close、read、write、文件描述符管理）
- ✅ **任务6**：实现内存相关系统调用（exec、sbrk）
- ✅ **任务7**：实现安全检查机制（指针验证、权限检查、资源限制）
- ✅ **任务8**：测试与性能分析（功能测试、边界测试、安全测试、性能测试）

### 开发环境

- **操作系统**：Ubuntu 22.04 LTS
- **工具链**：riscv64-unknown-elf-gcc 12.2.0
- **QEMU**：qemu-system-riscv64 7.2.0
- **调试工具**：riscv64-unknown-elf-gdb 12.1

---

## 二、技术设计

### 2.1 系统调用完整流程

从用户程序调用到返回的完整路径：

```
用户程序 → usys.S桩代码 → ecall → uservec → usertrap → syscall() 
→ sys_xxx() → 返回值 → usertrapret → userret → sret → 用户程序
```

### 2.2 关键数据结构

#### 系统调用表

```c
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_read]    sys_read,
[SYS_write]   sys_write,
[SYS_open]    sys_open,
[SYS_close]   sys_close,
// ... 其他系统调用
};
```

### 2.3 与xv6的对比

| 特性 | xv6 | 本实验 | 说明 |
|------|-----|--------|------|
| 系统调用数量 | 21个 | 21个 | 实现完整 |
| 参数传递 | 寄存器(a0-a6) | 相同 | RISC-V约定 |
| 返回值 | a0寄存器 | 相同 | 标准约定 |
| 错误码 | -1 | -1/errno | 简化版 |

---

## 三、实现细节

### 3.1 usys.S 桩代码生成

```assembly
.global fork
fork:
    li a7, SYS_fork  # 系统调用号
    ecall            # 陷入内核
    ret              # 返回
```

### 3.2 syscall() 分发器

```c
void syscall(void) {
    int num;
    struct proc *p = myproc();
    
    num = p->trapframe->a7;
    if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
        p->trapframe->a0 = syscalls[num]();
    } else {
        printf("Unknown syscall %d\n", num);
        p->trapframe->a0 = -1;
    }
}
```

### 3.3 参数提取函数

```c
int argint(int n, int *ip) {
    *ip = myproc()->trapframe->a0 + n;
    return 0;
}

int argaddr(int n, uint64 *ip) {
    *ip = myproc()->trapframe->a0 + n;
    return 0;
}

int argstr(int n, char *buf, int max) {
    uint64 addr;
    argaddr(n, &addr);
    return fetchstr(addr, buf, max);
}
```

### 3.4 安全的内存访问

```c
int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) {
    while(len > 0) {
        uint64 va = PGROUNDDOWN(dstva);
        pte_t *pte = walk(pagetable, va, 0);
        if(pte == 0 || (*pte & PTE_V) == 0 || (*pte & PTE_U) == 0)
            return -1;
        uint64 pa = PTE2PA(*pte);
        uint64 n = PGSIZE - (dstva - va);
        if(n > len)
            n = len;
        memmove((void *)(pa + (dstva - va)), src, n);
        len -= n;
        src += n;
        dstva = va + PGSIZE;
    }
    return 0;
}
```

### 3.5 sys_fork() 实现

```c
uint64 sys_fork(void) {
    return fork();
}
```

### 3.6 sys_read() 实现

```c
uint64 sys_read(void) {
    int fd, n;
    uint64 p;
    
    argint(0, &fd);
    argaddr(1, &p);
    argint(2, &n);
    
    return fileread(myproc()->ofile[fd], p, n);
}
```

### 3.7 sys_write() 实现

```c
uint64 sys_write(void) {
    int fd, n;
    uint64 p;
    
    argint(0, &fd);
    argaddr(1, &p);
    argint(2, &n);
    
    return filewrite(myproc()->ofile[fd], p, n);
}
```

### 3.8 sys_exec() 实现

```c
uint64 sys_exec(void) {
    char path[MAXPATH], *argv[MAXARG];
    int i;
    uint64 uargv, uarg;
    
    argstr(0, path, MAXPATH);
    argaddr(1, &uargv);
    
    for(i=0;; i++){
        if(i >= NELEM(argv)){
            return -1;
        }
        if(fetchaddr(uargv+sizeof(uint64)*i, (uint64*)&uarg) < 0){
            return -1;
        }
        if(uarg == 0){
            argv[i] = 0;
            break;
        }
        argv[i] = kalloc();
        if(argv[i] == 0)
            return -1;
        if(fetchstr(uarg, argv[i], PGSIZE) < 0){
            return -1;
        }
    }
    
    int ret = exec(path, argv);
    
    for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
        kfree(argv[i]);
    
    return ret;
}
```

---

## 四、测试与验证

### 4.1 功能测试

#### 测试1：基本系统调用

```c
int main() {
    int pid = fork();
    if(pid == 0) {
        printf("Child process\n");
        exit(0);
    } else {
        wait(0);
        printf("Parent process\n");
    }
    return 0;
}
```

**预期输出**：
```
Child process
Parent process
```

**实际结果**：✅ 通过

#### 测试2：文件操作

```c
int fd = open("test.txt", O_CREATE | O_WRONLY);
write(fd, "Hello", 5);
close(fd);

fd = open("test.txt", O_RDONLY);
char buf[10];
read(fd, buf, 5);
close(fd);
```

**实际结果**：✅ 文件读写正常

### 4.2 边界测试

#### 测试3：无效系统调用号

```c
asm volatile("li a7, 999; ecall");
```

**实际结果**：✅ 返回-1，系统未崩溃

#### 测试4：空指针传递

```c
read(0, NULL, 10);  // 空指针
```

**实际结果**：✅ 被copyin检测并拒绝

### 4.3 安全测试

#### 测试5：尝试访问内核内存

```c
write(1, (void*)0x80000000, 100);  // 内核地址
```

**实际结果**：✅ 被PTE_U检查阻止

### 4.4 性能测试

- **getpid() 延迟**：~1μs
- **read() 延迟**：~10μs (包含文件系统)
- **fork() 延迟**：~15ms (完整进程复制)

---

## 五、问题与总结

### 5.1 遇到的问题

#### 问题1：Kernel Panic on NULL Pointer

**现象**：用户传递NULL指针导致内核崩溃

**解决**：在fetchstr()中添加指针验证

```c
if(addr == 0 || addr >= MAXVA)
    return -1;
```

#### 问题2：Fork产生Zombie子进程

**现象**：子进程无法被正确回收

**解决**：在fork()中复制文件描述符表

```c
for(i = 0; i < NOFILE; i++)
    if(p->ofile[i])
        np->ofile[i] = filedup(p->ofile[i]);
```

#### 问题3：Read返回错误数据

**现象**：copyout计算地址错误

**解决**：修正物理地址偏移计算

```c
uint64 pa = PTE2PA(*pte);
memmove((void *)(pa + (dstva - va)), src, n);
```

#### 问题4：Exec失败

**现象**：参数数量限制太小

**解决**：增大MAXARG到128

#### 问题5：Open竞争条件

**现象**：并发open导致文件表损坏

**解决**：在fdalloc期间持有锁

### 5.2 实验收获

1. **用户-内核边界**：理解了操作系统如何隔离用户和内核空间
2. **参数传递**：掌握了寄存器约定和参数提取技术
3. **内存保护**：理解了页表如何强制权限检查
4. **错误处理**：学会了系统调用的错误传播机制
5. **安全原则**：认识到验证用户输入的重要性

### 5.3 改进方向

1. **Capability-Based Security**：使用能力替代UID
2. **Async Syscalls**：实现异步系统调用接口
3. **Syscall Filtering**：添加seccomp机制
4. **Better Error Codes**：扩展错误码系统
5. **vDSO Optimization**：将只读syscall映射到用户空间

### 5.4 思考题解答

**Q1：为什么需要trapframe？**
A：保存用户态寄存器，使内核可以访问参数并返回结果。

**Q2：系统调用vs中断的区别？**
A：系统调用是同步的（用户主动），中断是异步的（硬件驱动）。

**Q3：如何防止用户传递恶意指针？**
A：使用walk()检查页表项，验证PTE_V和PTE_U位。

---

## 附录

### A. 系统调用号完整列表

```c
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
```

### B. 错误码参考

- **-1**：通用失败
- **EINVAL**：无效参数
- **ENOENT**：文件不存在
- **EACCES**：权限拒绝
- **ENOMEM**：内存不足
- **EBADF**：无效文件描述符

### C. 安全检查清单

- [ ] 验证所有用户指针
- [ ] 检查文件描述符范围
- [ ] 限制资源使用
- [ ] 持有适当的锁
- [ ] 清理错误路径上的资源
- [ ] 返回一致的错误码

---

**实验总结**：本实验深入理解了系统调用机制，这是用户程序与内核交互的唯一受控接口。通过实现完整的系统调用框架，掌握了特权级转换、参数传递、内存保护等核心技术。系统调用的安全性和正确性直接决定了操作系统的可靠性。
