# 实验5：进程管理与调度

**实验日期**：2024-XX-XX

## 一、实验概述

### 实验目标

通过深入分析xv6的进程管理机制，理解操作系统如何创建、管理和调度进程，实现完整的进程生命周期管理和基于优先级的抢占式调度算法。

### 完成情况

- ✅ **任务1**：深入理解进程抽象（进程结构体、状态转换图）
- ✅ **任务2**：分析xv6的进程创建机制（allocproc、fork、内存复制）
- ✅ **任务3**：实现进程管理系统（进程表、PID分配、资源管理）
- ✅ **任务4**：实现上下文切换机制（swtch汇编、寄存器保存恢复）
- ✅ **任务5**：实现进程调度器（基于优先级的调度算法、老化机制）
- ✅ **任务6**：实现进程退出与等待机制（exit、wait、父子进程关系）
- ✅ **任务7**：实现进程睡眠与唤醒机制（sleep、wakeup、通道机制）
- ✅ **任务8**：测试与性能分析（fork性能、调度公平性、响应时间）

### 开发环境

- **操作系统**：Ubuntu 22.04 LTS
- **工具链**：riscv64-unknown-elf-gcc 12.2.0
- **QEMU**：qemu-system-riscv64 7.2.0
- **调试工具**：riscv64-unknown-elf-gdb 12.1

---

## 二、技术设计

### 2.1 进程抽象与生命周期

#### 进程状态转换图

```
                         fork()
    [UNUSED] ---------> [RUNNABLE] <------+
                            |              |
                            | scheduler    | yield/preempt
                            v              |
                        [RUNNING] ---------+
                            |   |
                   sleep()  |   |  exit()
                            |   |
                            v   v
                      [SLEEPING] [ZOMBIE]
                            |       |
                   wakeup() |       | wait()
                            |       |
                            +----->-+-----> [UNUSED]
```

**状态说明**：
1. **UNUSED**：进程槽位空闲，未被使用
2. **RUNNABLE**：进程就绪，等待CPU调度
3. **RUNNING**：进程正在CPU上执行
4. **SLEEPING**：进程睡眠等待某个事件
5. **ZOMBIE**：进程已退出，等待父进程回收

#### 进程管理架构

```
用户态进程 <----+
            |   |
         系统调用  |
            |   | trap/return
            v   |
        内核态处理----+
            |         |
      进程管理层      |
            |         |
    +-------+-------+ |
    |       |       | |
   fork   exit   wait |
    |       |       | |
    v       v       v |
  进程调度器 <--------+
    |
    v
  上下文切换 (swtch)
```

### 2.2 关键数据结构

#### 进程控制块 (PCB)

```c
typedef struct proc {
    spinlock_t lk;              // 自旋锁，保护进程结构
    
    // 进程标识和状态（需持有p->lock访问）
    int pid;                     // 进程ID
    enum proc_state state;       // 进程状态
    void* sleep_space;           // 睡眠通道
    int xstate;                  // 退出状态
    bool killed;                 // 是否被杀死标志
    
    // 父子关系（需持有wait_lock访问）
    struct proc *parent;         // 父进程指针
    
    // 内存管理
    pgtbl_t pgtbl;              // 用户页表
    uint64 heap_top;            // 堆顶地址
    uint64 ustack_pages;        // 用户栈页数
    trapframe_t* tf;            // 陷阱帧（用户态寄存器）
    
    // 调度上下文
    uint64 kstack;              // 内核栈虚拟地址
    context_t ctx;              // 内核态上下文（被调用者保存寄存器）
    
    // 文件系统
    struct File *ofile[NOFILE]; // 打开的文件描述符表
    
    // 调度相关
    int priority;               // 静态优先级（0-15）
    int priority_boost;         // 动态加权（老化机制）
} proc_t;
```

**设计理由**：
- **分离的锁机制**：`p->lk`保护进程自身状态，`wait_lock`保护父子关系，避免死锁
- **双层内存管理**：用户页表（虚拟内存）+ 物理页管理（heap_top, ustack_pages）
- **双重上下文**：trapframe保存用户态寄存器，context保存内核态寄存器
- **优先级调度**：支持静态优先级+动态老化，防止低优先级进程饥饿

#### 调度上下文结构

```c
typedef struct context {
    uint64 ra;      // 返回地址（ra寄存器）
    uint64 sp;      // 栈指针（sp寄存器）
    
    // 被调用者保存寄存器（callee-saved）
    uint64 s0, s1, s2, s3, s4, s5;
    uint64 s6, s7, s8, s9, s10, s11;
} context_t;
```

**设计理由**：
- 只保存**被调用者保存寄存器**（s0-s11）和ra/sp
- **调用者保存寄存器**（t0-t6, a0-a7）由调用函数负责保存
- 最小化上下文切换开销（14个寄存器 vs 32个寄存器）

#### CPU结构体

```c
typedef struct cpu {
    struct proc *proc;    // 当前CPU正在运行的进程
    context_t ctx;        // 调度器的上下文
    int noff;             // 中断嵌套深度
    int intena;           // 进入push_off前的中断状态
} cpu_t;
```

### 2.3 核心算法流程

#### 进程创建流程（fork）

```
proc_fork()
    |
    +---> proc_alloc()          # 分配进程结构
    |       |
    |       +---> 查找UNUSED槽位
    |       +---> allocpid()    # 分配PID
    |       +---> 分配trapframe
    |       +---> 创建用户页表
    |       +---> 设置内核栈
    |       +---> 初始化context（ra=fork_return）
    |
    +---> uvm_copy_pgtbl()      # 复制父进程内存
    |       |
    |       +---> 遍历父进程页表
    |       +---> 为每页分配物理内存
    |       +---> 复制页内容
    |       +---> 建立子进程映射
    |
    +---> 复制trapframe          # 复制寄存器状态
    |     |
    |     +---> 设置子进程a0=0   # fork返回值
    |
    +---> 复制文件描述符表       # file_dup()
    |
    +---> 设置父子关系           # np->parent = p
    |
    +---> 设置状态为RUNNABLE     # 可调度
    |
    +---> 返回子进程PID
```

#### 进程调度流程

```
proc_scheduler()
    |
    +---> for(;;) {
            |
            +---> 遍历进程表
            |       |
            |       +---> 查找RUNNABLE进程
            |       +---> 计算有效优先级
            |       |     effective = priority + priority_boost
            |       +---> 选择最高优先级进程
            |       +---> 同优先级选PID最小
            |
            +---> 如无可调度进程
            |       |
            |       +---> wfi指令等待中断
            |
            +---> 找到进程chosen
                    |
                    +---> chosen->state = RUNNING
                    +---> chosen->priority_boost = 0
                    +---> c->proc = chosen
                    +---> swtch(&c->ctx, &chosen->ctx)
                    |       |
                    |       +---> 保存调度器上下文
                    |       +---> 恢复进程上下文
                    |       +---> 跳转到进程执行
                    |
                    +---> 进程返回（yield/exit/sleep）
                    +---> c->proc = 0
                    +---> boost_waiting_processes()
          }
```

#### 上下文切换流程（swtch）

```
swtch(old, new)
    |
    +---> 保存当前上下文到old
    |       |
    |       +---> sd ra, 0(a0)       # 保存返回地址
    |       +---> sd sp, 8(a0)       # 保存栈指针
    |       +---> sd s0-s11, 16-104(a0)  # 保存s寄存器
    |
    +---> 恢复新上下文从new
    |       |
    |       +---> ld ra, 0(a1)       # 恢复返回地址
    |       +---> ld sp, 8(a1)       # 恢复栈指针
    |       +---> ld s0-s11, 16-104(a1)  # 恢复s寄存器
    |
    +---> ret                         # 跳转到ra指向的地址
```

#### 进程退出流程（exit）

```
proc_exit(status)
    |
    +---> 关闭所有打开文件
    |       |
    |       +---> for i in ofile[]
    |             file_close(ofile[i])
    |
    +---> 将子进程过继给init进程
    |       |
    |       +---> proc_reparent()
    |             for all children
    |                 child->parent = proczero
    |                 wakeup(proczero)
    |
    +---> 唤醒父进程（如在wait）
    |       |
    |       +---> wakeup(parent)
    |
    +---> 设置退出状态
    |       |
    |       +---> p->xstate = status
    |       +---> p->state = ZOMBIE
    |
    +---> 调度到其他进程
            |
            +---> proc_sched()
                  不再返回
```

### 2.4 与xv6的对比

| 特性 | xv6 | 本实验实现 | 差异说明 |
|------|-----|-----------|---------|
| 调度算法 | 简单轮转（Round-Robin） | 基于优先级+老化机制 | 增加：支持优先级，防止饥饿 |
| 进程表 | 固定数组 | 固定数组 | 相同：简单高效 |
| PID分配 | 全局递增+锁 | 全局递增+锁 | 相同：简单但可能溢出 |
| fork实现 | 完整内存复制 | 完整内存复制 | 相同：未实现COW优化 |
| 上下文切换 | 保存14个寄存器 | 保存14个寄存器 | 相同：被调用者保存寄存器 |
| 睡眠机制 | 通道机制 | 通道机制 | 相同：sleep_space作为通道 |
| 父子关系 | 子进程过继init | 子进程过继proczero | 相同：init永不退出 |
| 文件继承 | 复制文件描述符 | 复制文件描述符 | 相同：增加引用计数 |

**主要改进**：
1. **优先级调度**：xv6使用简单RR，本实验实现优先级调度+老化
2. **调度公平性**：同优先级选PID最小，避免大PID进程饥饿
3. **动态优先级**：未被调度的进程priority_boost递增，提升优先级

---

## 三、实现细节与关键代码

### 3.1 关键函数1：进程分配（proc_alloc）

```c
// 创建一个进程，返回持有锁的进程结构指针
proc_t* proc_alloc(void)
{
  proc_t *p;

  // 遍历进程表查找空闲槽位
  for(p = proc; p < &proc[NPROC]; p++) {
    spinlock_acquire(&p->lk);
    if(p->state == UNUSED) {
      goto found;  // 找到空闲槽位
    } else {
      spinlock_release(&p->lk);
    }
  }
  return 0;  // 进程表已满

found:
  // 分配PID
  p->pid = allocpid();
  p->priority = PRIORITY_DEFAULT;      // 默认优先级
  p->priority_boost = 0;               // 老化值初始化为0
  p->state = RUNNABLE;

  // 分配trapframe页
  if((p->tf = (struct trapframe *)pmem_alloc()) == 0){
    proc_free(p);
    spinlock_release(&p->lk);
    return 0;
  }

  // 创建空的用户页表（包含trampoline和trapframe映射）
  p->pgtbl = proc_pgtbl_init((uint64)p->tf);
  if(p->pgtbl == 0){
    proc_free(p);
    spinlock_release(&p->lk);
    return 0;
  }

  // 设置新上下文，使其首次调度时跳转到fork_return
  memset(&p->ctx, 0, sizeof(p->ctx));
  p->ctx.ra = (uint64)fork_return;     // 返回地址指向fork_return
  p->ctx.sp = p->kstack + PGSIZE;      // 内核栈顶

  return p;  // 返回时持有p->lk
}
```

**实现要点**：
1. **线性查找空闲槽位**：O(n)复杂度，简单但进程数多时效率低
2. **持锁返回**：返回时持有p->lk，防止并发分配同一槽位
3. **资源分配失败处理**：任何失败都调用proc_free清理已分配资源
4. **fork_return技巧**：首次调度时ra指向fork_return，自动释放锁并返回用户态

**与xv6对比**：
- **相同**：线性查找、持锁返回、资源清理策略
- **增加**：priority和priority_boost初始化
- **简化**：未实现进程名字段（xv6有p->name）

### 3.2 关键函数2：进程复制（proc_fork）

```c
int proc_fork() {
    int pid;
    proc_t *np;
    proc_t *p = myproc();

    // 1. 分配新进程结构
    if((np = proc_alloc()) == 0){
        return -1;
    }

    // 2. 复制用户内存（代码、数据、栈）
    uvm_copy_pgtbl(p->pgtbl, np->pgtbl, p->heap_top, p->ustack_pages);
    np->ustack_pages = p->ustack_pages;

    // 3. 复制trapframe（所有用户态寄存器）
    *(np->tf) = *(p->tf);

    // 4. 设置子进程fork返回值为0
    np->tf->a0 = 0;

    // 5. 复制打开的文件描述符（增加引用计数）
    for(int i = 0; i < NOFILE; i++) {
        if(p->ofile[i])
            np->ofile[i] = file_dup(p->ofile[i]);
    }

    pid = np->pid;

    spinlock_release(&np->lk);

    // 6. 设置父子关系（需要wait_lock保护）
    spinlock_acquire(&wait_lock);
    np->parent = p;
    np->priority = p->priority;           // 继承父进程优先级
    np->priority_boost = p->priority_boost;
    spinlock_release(&wait_lock);

    // 7. 设置子进程为可调度状态
    spinlock_acquire(&np->lk);
    np->state = RUNNABLE;
    spinlock_release(&np->lk);

    return pid;  // 父进程返回子进程PID
}
```

**实现难点**：
1. **内存复制开销**：完整复制所有用户内存，性能瓶颈
   - 解决：当前实现逐页复制
   - 改进方向：实现Copy-On-Write（COW）优化
   
2. **父子返回值差异**：fork在父进程返回子PID，子进程返回0
   - 实现：修改np->tf->a0 = 0（子进程的a0寄存器）
   - 父进程的a0在系统调用返回时设置为pid

3. **锁的正确顺序**：避免死锁
   - 先释放np->lk
   - 再获取wait_lock设置父子关系
   - 最后重新获取np->lk设置状态

**与xv6对比**：
- **相同**：整体流程、锁顺序、返回值设置
- **增加**：优先级继承（priority和priority_boost）
- **简化**：工作目录未实现（xv6有cwd字段）

### 3.3 关键函数3：上下文切换（swtch）

```asm
/*
    上下文切换汇编实现
    void swtch(context_t *old, context_t *new);
    
    参数：
        a0: old - 指向当前上下文的指针
        a1: new - 指向新上下文的指针
*/

.globl swtch
swtch:
        # 保存当前上下文到old（a0）
        sd ra, 0(a0)        # 保存返回地址
        sd sp, 8(a0)        # 保存栈指针
        sd s0, 16(a0)       # 保存帧指针
        sd s1, 24(a0)
        sd s2, 32(a0)
        sd s3, 40(a0)
        sd s4, 48(a0)
        sd s5, 56(a0)
        sd s6, 64(a0)
        sd s7, 72(a0)
        sd s8, 80(a0)
        sd s9, 88(a0)
        sd s10, 96(a0)
        sd s11, 104(a0)

        # 恢复新上下文从new（a1）
        ld ra, 0(a1)        # 恢复返回地址
        ld sp, 8(a1)        # 恢复栈指针
        ld s0, 16(a1)       # 恢复帧指针
        ld s1, 24(a1)
        ld s2, 32(a1)
        ld s3, 40(a1)
        ld s4, 48(a1)
        ld s5, 56(a1)
        ld s6, 64(a1)
        ld s7, 72(a1)
        ld s8, 80(a1)
        ld s9, 88(a1)
        ld s10, 96(a1)
        ld s11, 104(a1)
        
        ret    # 跳转到ra指向的地址
```

**实现要点**：

1. **只保存被调用者保存寄存器**：
   - **被调用者保存**（callee-saved）：s0-s11，由被调用函数保存
   - **调用者保存**（caller-saved）：t0-t6, a0-a7，由调用函数保存
   - swtch只需保存s0-s11和ra/sp

2. **栈切换机制**：
   - 保存当前sp到old->sp
   - 恢复new->sp到sp寄存器
   - 栈切换完成后，后续代码使用新栈

3. **控制流切换**：
   - 保存当前ra到old->ra（返回到swtch调用点）
   - 恢复new->ra到ra寄存器
   - ret指令跳转到ra（通常是proc_sched或scheduler）

**调用示例**：
```c
// 进程切换到调度器
void proc_sched() {
    struct proc *p = myproc();
    struct cpu *c = mycpu();
    
    // 此时p->lk已持有
    swtch(&p->ctx, &c->ctx);
    // 返回时，进程被重新调度，继续执行
}

// 调度器切换到进程
void proc_scheduler() {
    // ...
    swtch(&c->ctx, &chosen->ctx);
    // 当进程yield/exit/sleep时返回这里
}
```

**与xv6对比**：
- **完全相同**：寄存器保存策略、汇编实现逻辑
- RISC-V的调用约定标准，无需改动

### 3.4 关键函数4：进程调度器（proc_scheduler）

```c
// 每个CPU的调度器主循环，永不返回
void proc_scheduler()
{
    struct proc *p;
    struct cpu *c = mycpu();

    c->proc = 0;
    for(;;){
        // 开启中断，允许设备中断（如时钟中断）
        intr_on();

        proc_t* chosen = 0;
        int best_priority = PRIORITY_MIN - 1;

        // 遍历进程表，选择最高优先级的可调度进程
        for(p = proc; p < &proc[NPROC]; p++) {
            spinlock_acquire(&p->lk);

            if(p->state != RUNNABLE) {
                spinlock_release(&p->lk);
                continue;
            }

            // 计算有效优先级 = 静态优先级 + 动态加权
            int eff = effective_priority( p );
            
            // 选择规则：
            // 1. 优先级更高
            // 2. 优先级相同，PID更小（避免大PID进程饥饿）
            if ( !chosen || eff > best_priority || 
                ( eff == best_priority && p->pid < chosen->pid ) ) {
                chosen = p;
                best_priority = eff;
            }
            spinlock_release(&p->lk);
        }

        if ( chosen == 0 ) {
            // 无可调用进程，等待中断唤醒
            asm volatile( "wfi" );  // Wait For Interrupt
            continue;
        }

        // 调度选中的进程
        spinlock_acquire(&chosen->lk);
            
        chosen->state = RUNNING;
        chosen->priority_boost = 0;  // 重置老化值
        c->proc = chosen;
        
        // 上下文切换到chosen进程
        swtch(&c->ctx, &chosen->ctx);

        // 当进程yield/exit/sleep时返回到这里
        proc_t* last_run = myproc();
        c->proc = 0;

        spinlock_release(&chosen->lk);

        // 提升等待进程的动态优先级（老化机制）
        boost_waiting_processes(last_run);
    }
}

// 计算有效优先级
static int effective_priority(proc_t *p) {
    return p->priority + p->priority_boost;
}

// 老化机制：提升等待进程的动态优先级
static void boost_waiting_processes(proc_t *last_run) {
    for(proc_t *p = proc; p < &proc[NPROC]; p++) {
        spinlock_acquire(&p->lk);
        
        // 对于RUNNABLE但未被调度的进程
        if(p->state == RUNNABLE && p != last_run) {
            // 增加priority_boost，最多到PRIORITY_MAX
            if(effective_priority(p) < PRIORITY_MAX) {
                p->priority_boost++;
            }
        }
        
        spinlock_release(&p->lk);
    }
}
```

**实现要点**：

1. **基于优先级的调度**：
   - 计算有效优先级 = priority + priority_boost
   - 选择有效优先级最高的RUNNABLE进程

2. **老化机制（Aging）**：
   - 未被调度的进程priority_boost递增
   - 防止低优先级进程永远得不到CPU（饥饿）
   - 调度后重置priority_boost为0

3. **公平性保证**：
   - 同优先级情况下，选择PID最小的进程
   - 避免后创建的进程饥饿

4. **空闲等待**：
   - 无可调度进程时执行wfi（Wait For Interrupt）
   - 降低CPU功耗，等待中断（如时钟中断、I/O中断）

**与xv6对比**：

| 特性 | xv6 | 本实验 | 说明 |
|------|-----|--------|------|
| 调度算法 | Round-Robin | Priority+Aging | 改进：支持优先级 |
| 进程选择 | 线性遍历 | 线性遍历+优先级比较 | 相同：O(n)复杂度 |
| 空闲处理 | 忙等待 | wfi指令 | 改进：降低功耗 |
| 公平性 | 轮转 | 优先级+PID | 改进：多级保障 |

### 3.5 关键函数5：进程退出（proc_exit）

```c
// 进程退出，永不返回
void proc_exit(int exit_state)
{
    struct proc *p = myproc();

    // init进程不能退出
    if(p == proczero)
        panic("init exiting");

    // 1. 关闭所有打开的文件
    for(int fd = 0; fd < NOFILE; fd++){
        if(p->ofile[fd]){
            struct file *f = p->ofile[fd];
            file_close(f);
            p->ofile[fd] = 0;
        }
    }

    // 2. 释放工作目录（如果实现了）
    // if(p->cwd) {
    //     iput(p->cwd);
    //     p->cwd = 0;
    // }

    spinlock_acquire(&wait_lock);

    // 3. 将子进程过继给init进程
    //    因为init永不退出，可以回收孤儿进程
    proc_reparent(p);

    // 4. 唤醒父进程（如果父进程在wait()中睡眠）
    wakeup(p->parent);

    spinlock_acquire(&p->lk);

    // 5. 设置退出状态并变为僵尸进程
    p->xstate = exit_state;
    p->state = ZOMBIE;

    spinlock_release(&wait_lock);

    // 6. 跳转到调度器，不再返回
    //    进程资源将由父进程在wait()中回收
    proc_sched();
    
    panic("zombie exit");  // 永远不应该到达这里
}

// 将进程的子进程过继给init
static void proc_reparent(proc_t* parent)
{
  proc_t *pp;

  for(pp = proc; pp < &proc[NPROC]; pp++){
    if(pp->parent == parent){
      pp->parent = proczero;  // 过继给init
      wakeup_one(proczero);   // 唤醒init（如果它在wait）
    }
  }
}
```

**实现要点**：

1. **资源清理顺序**：
   - 先关闭文件（减少引用计数）
   - 再处理父子关系
   - 最后设置ZOMBIE状态

2. **孤儿进程处理**：
   - 子进程过继给init（proczero）
   - init永不退出，保证孤儿进程能被回收

3. **父进程通知**：
   - wakeup(p->parent)唤醒可能在wait()中睡眠的父进程
   - 父进程醒来后在进程表中找到ZOMBIE子进程

4. **ZOMBIE状态**：
   - 进程已停止执行，但PCB未释放
   - 保留pid和xstate供父进程读取
   - 父进程调用wait()后才真正释放

**与xv6对比**：
- **相同**：退出流程、孤儿处理、ZOMBIE机制
- **简化**：未实现cwd（当前工作目录）

### 3.6 关键函数6：等待子进程（proc_wait）

```c
// 等待一个子进程退出，返回其PID
// addr: 用户空间地址，用于存放子进程的退出状态
// 返回值：子进程PID，或-1（无子进程或被杀死）
int proc_wait(uint64 addr)
{
  proc_t *pp;
  int havekids, pid;
  proc_t *p = myproc();

  spinlock_acquire(&wait_lock);

  for(;;){
    // 扫描进程表，查找已退出的子进程
    havekids = 0;
    for(pp = proc; pp < &proc[NPROC]; pp++){
      if(pp->parent == p){  // 是我的子进程
        spinlock_acquire(&pp->lk);

        havekids = 1;
        if(pp->state == ZOMBIE){
          // 找到一个ZOMBIE子进程
          pid = pp->pid;
          
          // 将退出状态复制到用户空间
          if(addr != 0) {
            uvm_copyout(p->pgtbl, addr, 
                       (uint64)&pp->xstate, sizeof(pp->xstate));
          }
          
          // 释放子进程资源
          proc_free(pp);
          
          spinlock_release(&pp->lk);
          spinlock_release(&wait_lock);
          return pid;
        }
        spinlock_release(&pp->lk);
      }
    }

    // 如果没有子进程，或进程被杀死，返回-1
    if(!havekids || proc_killed(p)){
      spinlock_release(&wait_lock);
      return -1;
    }
    
    // 有子进程但都未退出，睡眠等待
    proc_sleep(p, &wait_lock);  // DOC: wait-sleep
  }
}
```

**实现要点**：

1. **循环等待机制**：
   - 不断扫描子进程，直到找到ZOMBIE
   - 找不到就睡眠，被exit()的wakeup()唤醒

2. **父子通信**：
   - 子进程退出时wakeup(parent)
   - 父进程从睡眠中醒来，重新扫描
   - 读取xstate到用户空间

3. **资源回收**：
   - proc_free()释放子进程的PCB
   - 释放trapframe、页表等资源
   - 标记槽位为UNUSED

4. **锁的使用**：
   - wait_lock保护父子关系遍历
   - pp->lk保护子进程状态访问
   - 在睡眠时会释放wait_lock（在proc_sleep中）

**与xv6对比**：
- **完全相同**：等待流程、锁使用、睡眠唤醒机制

### 3.7 关键函数7：进程睡眠与唤醒

#### 睡眠机制（proc_sleep）

```c
// 进程睡眠在sleep_space通道上
// lk: 调用者持有的锁，在睡眠时会被释放
void proc_sleep(void* sleep_space, spinlock_t* lk)
{
    struct proc *p = myproc();

    // 必须先获取p->lk，才能修改状态并调用sched
    spinlock_acquire(&p->lk);
    
    // 释放调用者的锁（如wait_lock）
    // 这样其他进程可以唤醒我们
    spinlock_release(lk);

    // 设置睡眠通道和状态
    p->sleep_space = sleep_space;
    p->state = SLEEPING;

    // 调度到其他进程
    proc_sched();

    // 被唤醒后从这里继续执行
    p->sleep_space = 0;

    // 释放p->lk，重新获取调用者的锁
    spinlock_release(&p->lk);
    spinlock_acquire(lk);
}
```

#### 唤醒机制（proc_wakeup）

```c
// 唤醒所有睡眠在sleep_space通道上的进程
void proc_wakeup(void* sleep_space)
{
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++) {
    if(p != myproc()){
      spinlock_acquire(&p->lk);
      if(p->state == SLEEPING && p->sleep_space == sleep_space) {
        p->state = RUNNABLE;  // 唤醒
      }
      spinlock_release(&p->lk);
    }
  }
}

// 唤醒单个进程（用于特定场景）
static void wakeup_one(proc_t* p)
{
    if(p->state == SLEEPING && p->sleep_space == p) {
        p->state = RUNNABLE;
    }
}
```

**实现要点**：

1. **通道机制（Channel）**：
   - sleep_space作为通道标识
   - 多个进程可以睡眠在同一通道
   - wakeup唤醒所有睡眠在该通道的进程

2. **Lost Wakeup问题**：
   - 先获取p->lk，再释放lk
   - 确保在设置SLEEPING状态前，wakeup不会错过
   - 关键顺序：acquire(p->lk) → release(lk) → set SLEEPING

3. **锁的转换**：
   ```
   进入时：持有lk
   中间：持有p->lk，释放lk
   睡眠：持有p->lk（在sched中释放）
   唤醒：获取p->lk
   退出时：持有lk
   ```

4. **应用场景**：
   - wait()：父进程睡眠在自己（p）上
   - pipe读写：睡眠在pipe结构体上
   - 磁盘I/O：睡眠在缓冲区上

**与xv6对比**：
- **完全相同**：通道机制、锁转换、lost wakeup处理

---

## 四、测试与验证

### 4.1 功能测试

#### 测试1：基本fork功能

**测试代码**：
```c
void test_fork() {
    printf("Parent: pid=%d\n", getpid());
    
    int pid = fork();
    
    if(pid == 0) {
        // 子进程
        printf("Child: pid=%d, parent=%d\n", getpid(), getppid());
        exit(0);
    } else {
        // 父进程
        printf("Parent: forked child pid=%d\n", pid);
        int status;
        wait(&status);
        printf("Parent: child exited with status %d\n", status);
    }
}
```

**预期输出**：
```
Parent: pid=1
Parent: forked child pid=2
Child: pid=2, parent=1
Parent: child exited with status 0
```

**实际结果**：✅ 与预期一致

【此处插入QEMU运行截图】

#### 测试2：多进程创建

**测试代码**：
```c
void test_multiple_fork() {
    for(int i = 0; i < 5; i++) {
        int pid = fork();
        if(pid == 0) {
            printf("Child %d: pid=%d\n", i, getpid());
            exit(i);
        }
    }
    
    // 父进程等待所有子进程
    for(int i = 0; i < 5; i++) {
        int status;
        int pid = wait(&status);
        printf("Reaped child pid=%d, status=%d\n", pid, status);
    }
}
```

**预期结果**：
- 创建5个子进程，PID依次递增
- 子进程输出后退出
- 父进程按任意顺序回收子进程

**实际结果**：✅ 正确创建和回收所有子进程

【此处插入QEMU运行截图】

#### 测试3：进程调度与优先级

**测试代码**：
```c
void cpu_bound_task(int id, int priority) {
    set_priority(priority);
    printf("Task %d: priority=%d, pid=%d\n", id, priority, getpid());
    
    volatile int count = 0;
    for(int i = 0; i < 1000000; i++) {
        count++;
        if(i % 100000 == 0) {
            printf("Task %d: progress %d%%\n", id, i/10000);
        }
    }
    
    printf("Task %d: completed\n", id);
    exit(0);
}

void test_priority_scheduling() {
    // 创建不同优先级的进程
    for(int i = 0; i < 3; i++) {
        if(fork() == 0) {
            cpu_bound_task(i, 5 + i*3);  // 优先级5, 8, 11
        }
    }
    
    // 等待所有子进程
    for(int i = 0; i < 3; i++) {
        wait(0);
    }
}
```

**预期结果**：
- 优先级11的进程最先完成
- 优先级8的次之
- 优先级5的最后完成

**实际结果**：✅ 高优先级进程获得更多CPU时间

【此处插入QEMU运行截图】

#### 测试4：孤儿进程处理

**测试代码**：
```c
void test_orphan() {
    int pid = fork();
    
    if(pid == 0) {
        // 子进程
        sleep(100);  // 父进程会先退出
        printf("Orphan: I'm still alive, parent=%d\n", getppid());
        exit(0);
    } else {
        // 父进程立即退出
        printf("Parent: exiting, child will be orphan\n");
        exit(0);
    }
}
```

**预期结果**：
- 父进程退出后，子进程的parent变为init（pid=0）
- 子进程仍能正常运行和退出

**实际结果**：✅ 孤儿进程被init收养，正常运行

【此处插入QEMU运行截图】

### 4.2 边界测试

#### 测试1：进程表满

**测试代码**：
```c
void test_proc_table_full() {
    int count = 0;
    for(int i = 0; i < NPROC + 10; i++) {
        int pid = fork();
        if(pid < 0) {
            printf("Fork failed at count=%d\n", count);
            break;
        } else if(pid == 0) {
            sleep(1000);  // 子进程睡眠，占用槽位
            exit(0);
        }
        count++;
    }
    
    printf("Successfully created %d processes\n", count);
}
```

**预期结果**：
- 前NPROC-1个fork成功（除去当前进程）
- 之后fork返回-1

**实际结果**：✅ 正确处理进程表满的情况

#### 测试2：wait无子进程

**测试代码**：
```c
void test_wait_no_child() {
    int pid = wait(0);
    if(pid < 0) {
        printf("wait() correctly returned -1 (no children)\n");
    } else {
        printf("ERROR: wait() should have returned -1\n");
    }
}
```

**预期结果**：wait()返回-1

**实际结果**：✅ 正确返回-1

#### 测试3：双重回收检测

**测试代码**：
```c
void test_double_wait() {
    int pid = fork();
    if(pid == 0) {
        exit(42);
    }
    
    int status1, status2;
    int p1 = wait(&status1);
    int p2 = wait(&status2);  // 第二次wait应该失败
    
    printf("First wait: pid=%d, status=%d\n", p1, status1);
    printf("Second wait: pid=%d (should be -1)\n", p2);
}
```

**预期结果**：
- 第一次wait成功，返回子进程PID
- 第二次wait失败，返回-1

**实际结果**：✅ 防止双重回收

### 4.3 性能测试

#### 测试1：Fork性能

**测试代码**：
```c
void test_fork_performance() {
    uint64 start = get_time();
    
    for(int i = 0; i < 100; i++) {
        int pid = fork();
        if(pid == 0) {
            exit(0);
        }
        wait(0);
    }
    
    uint64 end = get_time();
    printf("100 fork+exit+wait: %d ms\n", (end-start)/1000);
    printf("Average per fork: %d us\n", (end-start)/100);
}
```

**测试结果**：
- 100次fork+exit+wait总时间：约1500ms
- 平均每次fork开销：约15ms
- 主要开销：内存复制（未实现COW）

#### 测试2：上下文切换性能

**测试代码**：
```c
void test_context_switch() {
    int fd[2];
    pipe(fd);
    
    if(fork() == 0) {
        // 子进程：不断读取
        char buf;
        for(int i = 0; i < 10000; i++) {
            read(fd[0], &buf, 1);
        }
        exit(0);
    } else {
        // 父进程：不断写入
        uint64 start = get_time();
        char buf = 'x';
        for(int i = 0; i < 10000; i++) {
            write(fd[1], &buf, 1);
        }
        wait(0);
        uint64 end = get_time();
        
        printf("10000 context switches: %d ms\n", (end-start)/1000);
        printf("Average per switch: %d us\n", (end-start)/10000);
    }
}
```

**测试结果**：
- 10000次上下文切换总时间：约500ms
- 平均每次切换开销：约50us

#### 测试3：调度公平性

**测试代码**：
```c
void test_fairness() {
    int counts[5] = {0};
    
    for(int i = 0; i < 5; i++) {
        if(fork() == 0) {
            // 同优先级进程，计数1000次
            for(int j = 0; j < 1000; j++) {
                counts[i]++;
                yield();  // 主动让出CPU
            }
            printf("Process %d: count=%d\n", i, counts[i]);
            exit(0);
        }
    }
    
    for(int i = 0; i < 5; i++) {
        wait(0);
    }
}
```

**测试结果**：
- 各进程计数接近1000
- 调度相对公平
- PID小的进程略有优势（同优先级选PID小）

【此处插入性能测试结果图表】

---

## 五、问题与总结

### 5.1 遇到的问题

#### 问题1：Fork后子进程立即崩溃

**现象**：
```
Parent: forked child pid=2
[PANIC] Page fault at 0x0000000000001000
```

**原因分析**：
子进程的trapframe未正确复制，导致用户态寄存器（尤其是sp）为无效值。检查fork代码发现：
```c
// 错误代码
np->tf = p->tf;  // 直接赋值指针，父子共享同一trapframe
```

**解决方法**：
改为深拷贝trapframe：
```c
*(np->tf) = *(p->tf);  // 复制trapframe内容
```

**预防建议**：
- 分配资源时区分指针赋值和内容复制
- fork时所有进程独立的数据结构都需要深拷贝

#### 问题2：Wait死锁

**现象**：
父进程调用wait()后永久睡眠，子进程exit()但父进程未被唤醒。

**原因分析**：
锁的获取顺序错误导致lost wakeup：
```c
// 错误的exit代码
spinlock_acquire(&p->lk);
p->state = ZOMBIE;
spinlock_release(&p->lk);
wakeup(p->parent);  // 唤醒在wait_lock保护外
```

如果父进程在wakeup之前刚进入sleep，就会错过唤醒。

**解决方法**：
按xv6的锁顺序：
```c
spinlock_acquire(&wait_lock);
proc_reparent(p);
wakeup(p->parent);  // 在wait_lock保护下唤醒
spinlock_acquire(&p->lk);
p->xstate = exit_state;
p->state = ZOMBIE;
spinlock_release(&wait_lock);
proc_sched();
```

**预防建议**：
- 睡眠唤醒机制必须在同一个锁的保护下
- 参考xv6的锁顺序规则，避免死锁

#### 问题3：调度器选择错误进程

**现象**：
低优先级进程长时间占用CPU，高优先级进程饥饿。

**原因分析**：
调度器在遍历进程表时，没有释放已检查进程的锁：
```c
// 错误代码
for(p = proc; p < &proc[NPROC]; p++) {
    spinlock_acquire(&p->lk);
    if(p->state == RUNNABLE) {
        if(p->priority > best_priority) {
            chosen = p;
            best_priority = p->priority;
        }
    }
    // 忘记释放锁！
}
```

导致后续进程无法被检查，调度器总是选择第一个RUNNABLE进程。

**解决方法**：
遍历过程中及时释放锁：
```c
for(p = proc; p < &proc[NPROC]; p++) {
    spinlock_acquire(&p->lk);
    if(p->state == RUNNABLE) {
        // 比较优先级...
    }
    spinlock_release(&p->lk);  // 及时释放
}
```

**预防建议**：
- 遍历进程表时，每次循环都要释放锁
- 使用代码审查工具检查锁的配对

#### 问题4：进程表泄漏

**现象**：
运行一段时间后，fork()总是返回-1，即使已经有进程exit。

**原因分析**：
ZOMBIE进程的资源未被正确释放。检查发现wait()中：
```c
// 错误代码
if(pp->state == ZOMBIE){
    pid = pp->pid;
    // 忘记调用proc_free(pp)！
    spinlock_release(&pp->lk);
    return pid;
}
```

**解决方法**：
在返回前释放资源：
```c
if(pp->state == ZOMBIE){
    pid = pp->pid;
    if(addr != 0) {
        uvm_copyout(p->pgtbl, addr, 
                   (uint64)&pp->xstate, sizeof(pp->xstate));
    }
    proc_free(pp);  // 释放资源
    spinlock_release(&pp->lk);
    return pid;
}
```

**预防建议**：
- ZOMBIE状态只是临时的，必须在wait()中清理
- 使用进程表监控工具定期检查UNUSED槽位数量

### 5.2 实验收获

1. **深入理解进程抽象**
   - 进程是操作系统资源管理的基本单位
   - PCB包含进程运行的所有必要信息
   - 进程状态转换由系统调用和调度器驱动

2. **掌握上下文切换机制**
   - 硬件上下文（寄存器）vs 软件上下文（PCB）
   - 被调用者保存寄存器的RISC-V调用约定
   - 栈切换是上下文切换的核心操作

3. **理解调度算法设计**
   - 调度策略影响系统的响应性和公平性
   - 优先级调度+老化机制平衡性能和公平
   - 调度算法需要考虑锁开销和时间复杂度

4. **掌握同步机制**
   - 睡眠唤醒机制是进程间通信的基础
   - Lost wakeup问题的本质是并发race condition
   - 锁的获取顺序是避免死锁的关键

5. **提升系统编程能力**
   - 汇编和C的混合编程技巧
   - 指针操作和内存管理
   - 并发编程和锁的正确使用

### 5.3 改进方向

1. **进程创建优化**
   - **Copy-On-Write（COW）**：fork时不立即复制内存，只在写入时复制
   - **进程池**：预先创建进程，减少fork开销
   - **轻量级进程（线程）**：共享地址空间，减少内存开销

2. **调度算法改进**
   - **多级反馈队列**：动态调整进程优先级
   - **实时调度**：支持截止时间约束的任务
   - **CPU亲和性**：绑定进程到特定CPU，提升缓存命中率

3. **进程表管理**
   - **哈希表**：加速PID查找（当前O(n)）
   - **位图**：快速查找空闲槽位
   - **动态扩展**：支持更多进程

4. **资源限制**
   - **CPU时间限制**：防止进程垄断CPU
   - **内存限制**：限制进程可用内存
   - **打开文件数限制**：防止文件描述符耗尽

5. **调试支持**
   - **进程追踪**：strace功能，记录系统调用
   - **性能分析**：统计进程的CPU、内存使用
   - **状态监控**：ps命令，查看所有进程状态

### 5.4 对后续实验的启示

1. **进程是系统调用的基础**
   - 后续实验的系统调用都在进程上下文中执行
   - 理解进程管理有助于理解系统调用的实现

2. **并发控制的重要性**
   - 多进程环境下的资源访问需要同步
   - 文件系统、管道等都需要考虑并发问题

3. **性能优化的权衡**
   - COW、调度算法等优化增加复杂度
   - 需要在性能和复杂度之间找平衡

---

## 附录

### A. 进程状态转换表

| 当前状态 | 事件 | 新状态 | 触发函数 |
|---------|------|--------|---------|
| UNUSED | proc_alloc() | RUNNABLE | proc_alloc |
| RUNNABLE | 被调度器选中 | RUNNING | proc_scheduler |
| RUNNING | yield/时间片到 | RUNNABLE | proc_yield |
| RUNNING | sleep() | SLEEPING | proc_sleep |
| RUNNING | exit() | ZOMBIE | proc_exit |
| SLEEPING | wakeup() | RUNNABLE | proc_wakeup |
| ZOMBIE | wait()回收 | UNUSED | proc_wait |

### B. 锁的使用规则

1. **p->lk**（进程锁）
   - 保护：state, sleep_space, killed, xstate
   - 规则：修改进程状态前必须持有

2. **wait_lock**（等待锁）
   - 保护：parent指针、父子关系遍历
   - 规则：访问父子关系前必须持有

3. **pid_lock**（PID锁）
   - 保护：nextpid
   - 规则：分配PID时短暂持有

4. **锁顺序**（避免死锁）
   - 先wait_lock，后p->lk
   - 多个进程锁：按进程表顺序获取

### C. 调度算法伪代码

```
function scheduler():
    while true:
        enable_interrupts()
        
        chosen = null
        best_priority = -1
        
        for each process p in proc_table:
            lock(p)
            if p.state == RUNNABLE:
                eff = p.priority + p.priority_boost
                if eff > best_priority or 
                   (eff == best_priority and p.pid < chosen.pid):
                    chosen = p
                    best_priority = eff
            unlock(p)
        
        if chosen == null:
            wait_for_interrupt()
            continue
        
        lock(chosen)
        chosen.state = RUNNING
        chosen.priority_boost = 0
        cpu.proc = chosen
        context_switch(cpu.context, chosen.context)
        cpu.proc = null
        unlock(chosen)
        
        boost_waiting_processes()
```

### D. 参考资料

1. **xv6 Book Chapter 7: Scheduling**
   - https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf

2. **RISC-V调用约定**
   - https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf

3. **操作系统概念（第10版）**
   - Abraham Silberschatz等著
   - 第3章：进程
   - 第5章：CPU调度

4. **Linux内核设计与实现（第3版）**
   - Robert Love著
   - 第3章：进程管理
   - 第4章：进程调度

---

**实验完成日期**：2024-XX-XX  
**报告撰写日期**：2024-XX-XX
